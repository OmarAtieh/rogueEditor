   1	from __future__ import annotations
   2	
   3	import os
   4	import sys
   5	import subprocess
   6	import tkinter as tk
   7	from tkinter import ttk, messagebox
   8	import threading
   9	import math
  10	
  11	from rogueeditor import PokerogueAPI
  12	from rogueeditor.editor import Editor
  13	from rogueeditor.utils import (
  14	    list_usernames,
  15	    sanitize_username,
  16	    save_client_session_id,
  17	    load_client_session_id,
  18	    set_user_csid,
  19	    trainer_save_path,
  20	    slot_save_path,
  21	)
  22	from rogueeditor.catalog import (
  23	    load_move_catalog,
  24	    load_ability_catalog,
  25	    load_nature_catalog,
  26	    load_ability_attr_mask,
  27	    load_item_catalog,
  28	)
  29	
  30	
  31	class App(tk.Tk):
  32	    def __init__(self):
  33	        super().__init__()
  34	        self.title("rogueEditor GUI")
  35	        self.geometry("900x600")
  36	        self.minsize(700, 480)
  37	        self.api: PokerogueAPI | None = None
  38	        self.editor: Editor | None = None
  39	        self.username: str | None = None
  40	
  41	        self._build_login()
  42	        self._build_actions()
  43	        self._build_console()
  44	
  45	    # --- UI builders ---
  46	    def _build_login(self):
  47	        frm = ttk.LabelFrame(self, text="Login")
  48	        frm.pack(fill=tk.X, padx=8, pady=8)
  49	
  50	        ttk.Label(frm, text="User:").grid(row=0, column=0, sticky=tk.W, padx=4, pady=4)
  51	        self.user_combo = ttk.Combobox(frm, values=list_usernames(), state="readonly")
  52	        self.user_combo.grid(row=0, column=1, sticky=tk.W, padx=4, pady=4)
  53	
  54	        ttk.Button(frm, text="New User", command=self._new_user_dialog).grid(row=0, column=2, padx=4)
  55	
  56	        ttk.Label(frm, text="Password:").grid(row=1, column=0, sticky=tk.W, padx=4, pady=4)
  57	        self.pass_entry = ttk.Entry(frm, show="*")
  58	        self.pass_entry.grid(row=1, column=1, sticky=tk.W, padx=4, pady=4)
  59	
  60	        ttk.Label(frm, text="clientSessionId (optional):").grid(row=2, column=0, sticky=tk.W, padx=4, pady=4)
  61	        self.csid_entry = ttk.Entry(frm, width=50)
  62	        self.csid_entry.grid(row=2, column=1, columnspan=2, sticky=tk.W, padx=4, pady=4)
  63	
  64	        ttk.Button(frm, text="Login", command=self._login).grid(row=3, column=1, pady=6)
  65	
  66	        self.status_var = tk.StringVar(value="Status: Not logged in")
  67	        ttk.Label(frm, textvariable=self.status_var).grid(row=4, column=0, columnspan=3, sticky=tk.W, padx=4, pady=4)
  68	        # Quick Actions toolbar (prominent backup/restore)
  69	        qa = ttk.Frame(frm)
  70	        qa.grid(row=5, column=0, columnspan=3, sticky=tk.W, padx=4, pady=4)
  71	        self.btn_backup = ttk.Button(qa, text="Backup All", command=self._safe(self._backup), state=tk.DISABLED)
  72	        self.btn_backup.pack(side=tk.LEFT, padx=4)
  73	        self.btn_restore = ttk.Button(qa, text="Restore Backup", command=self._safe(self._restore_dialog2), state=tk.DISABLED)
  74	        self.btn_restore.pack(side=tk.LEFT, padx=4)
  75	        self.backup_status_var = tk.StringVar(value="Last backup: none")
  76	        ttk.Label(qa, textvariable=self.backup_status_var).pack(side=tk.LEFT, padx=8)
  77	
  78	    def _build_actions(self):
  79	        # Scrollable container for actions
  80	        container = ttk.LabelFrame(self, text="Actions")
  81	        container.pack(fill=tk.BOTH, expand=True, padx=8, pady=4)
  82	        canvas = tk.Canvas(container, highlightthickness=0)
  83	        vsb = ttk.Scrollbar(container, orient="vertical", command=canvas.yview)
  84	        canvas.configure(yscrollcommand=vsb.set)
  85	        vsb.pack(side=tk.RIGHT, fill=tk.Y)
  86	        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
  87	        inner = ttk.Frame(canvas)
  88	        inner.bind(
  89	            "<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
  90	        )
  91	        canvas.create_window((0, 0), window=inner, anchor="nw")
  92	        self.actions_frame = inner
  93	
  94	        # Data IO
  95	        box1 = ttk.LabelFrame(inner, text="Data IO")
  96	        box1.pack(fill=tk.X, padx=6, pady=6)
  97	        ttk.Button(box1, text="Verify System Session", command=self._safe(self._verify)).grid(row=0, column=0, padx=4, pady=4, sticky=tk.W)
  98	        ttk.Button(box1, text="Dump Trainer", command=self._safe(self._dump_trainer)).grid(row=0, column=1, padx=4, pady=4, sticky=tk.W)
  99	        # Slot selection dropdown for dump/update
 100	        ttk.Label(box1, text="Slot:").grid(row=0, column=2, sticky=tk.E)
 101	        self.slot_var = tk.StringVar(value="1")
 102	        self.slot_combo = ttk.Combobox(box1, textvariable=self.slot_var, values=["1","2","3","4","5"], width=4, state="readonly")
 103	        self.slot_combo.grid(row=0, column=3, sticky=tk.W)
 104	        ttk.Button(box1, text="Dump Slot", command=self._safe(self._dump_slot_selected)).grid(row=0, column=4, padx=4, pady=4, sticky=tk.W)
 105	        # Upload actions
 106	        ttk.Button(box1, text="Upload Trainer (trainer.json)", command=self._safe(self._update_trainer)).grid(row=1, column=0, padx=4, pady=4, sticky=tk.W)
 107	        ttk.Button(box1, text="Upload Slot (slot N.json)", command=self._safe(self._update_slot_selected)).grid(row=1, column=1, padx=4, pady=4, sticky=tk.W)
 108	        ttk.Button(box1, text="Restore from Backup", command=self._safe(self._restore_dialog2)).grid(row=1, column=2, padx=4, pady=4, sticky=tk.W)
 109	        # Tools
 110	        ttk.Button(box1, text="Upload Local Changes...", command=self._safe(self._upload_local_dialog)).grid(row=2, column=0, padx=4, pady=4, sticky=tk.W)
 111	        ttk.Button(box1, text="Open Local Dump...", command=self._safe(self._open_local_dump_dialog)).grid(row=2, column=1, padx=4, pady=4, sticky=tk.W)
 112	
 113	        # Slots summary
 114	        boxS = ttk.LabelFrame(inner, text="Slots")
 115	        boxS.pack(fill=tk.BOTH, padx=6, pady=6)
 116	        cols = ("slot", "party", "playtime", "local")
 117	        self.slot_tree = ttk.Treeview(boxS, columns=cols, show="headings", height=6)
 118	        for c, w in (("slot", 60), ("party", 80), ("playtime", 120), ("local", 220)):
 119	            self.slot_tree.heading(c, text=c.capitalize())
 120	            self.slot_tree.column(c, width=w, anchor=tk.W)
 121	        self.slot_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
 122	        sb = ttk.Scrollbar(boxS, orient="vertical", command=self.slot_tree.yview)
 123	        self.slot_tree.configure(yscrollcommand=sb.set)
 124	        sb.pack(side=tk.RIGHT, fill=tk.Y)
 125	        self.slot_tree.tag_configure('empty', foreground='grey')
 126	        self.slot_tree.bind('<<TreeviewSelect>>', self._on_slot_select)
 127	        ttk.Button(boxS, text="Refresh Slots", command=self._safe(self._refresh_slots)).pack(anchor=tk.W, padx=4, pady=4)
 128	
 129	        # Team
 130	        box2 = ttk.LabelFrame(inner, text="Active Run Team")
 131	        box2.pack(fill=tk.X, padx=6, pady=6)
 132	        ttk.Button(box2, text="Analyze Team", command=self._safe(self._analyze_team_dialog)).pack(side=tk.LEFT, padx=4, pady=4)
 133	        ttk.Button(box2, text="Edit Team", command=self._safe(self._edit_team_dialog)).pack(side=tk.LEFT, padx=4, pady=4)
 134	        ttk.Button(box2, text="Analyze Run Conditions", command=self._safe(self._analyze_run_conditions)).pack(side=tk.LEFT, padx=4, pady=4)
 135	        ttk.Button(box2, text="Edit Run Weather", command=self._safe(self._edit_run_weather)).pack(side=tk.LEFT, padx=4, pady=4)
 136	
 137	        # Modifiers
 138	        box3 = ttk.LabelFrame(inner, text="Modifiers / Items")
 139	        box3.pack(fill=tk.BOTH, padx=6, pady=6)
 140	        # Modifiers manager
 141	        mod_btns = ttk.Frame(box3)
 142	        mod_btns.pack(fill=tk.X)
 143	        ttk.Button(mod_btns, text="Open Modifiers Manager", command=self._safe(self._open_mod_mgr)).pack(side=tk.LEFT, padx=4, pady=4)
 144	        ttk.Button(mod_btns, text="List Modifiers", command=self._safe(self._list_mods_dialog)).pack(side=tk.LEFT, padx=4, pady=4)
 145	        ttk.Button(mod_btns, text="Add Item to Mon", command=self._safe(self._add_item_dialog)).pack(side=tk.LEFT, padx=4, pady=4)
 146	        ttk.Button(mod_btns, text="Remove Item from Mon", command=self._safe(self._remove_item_dialog)).pack(side=tk.LEFT, padx=4, pady=4)
 147	
 148	        # Starters
 149	        box4 = ttk.LabelFrame(inner, text="Starters")
 150	        box4.pack(fill=tk.X, padx=6, pady=6)
 151	        # Pokemon selector
 152	        from rogueeditor.utils import load_pokemon_index
 153	        dex = (load_pokemon_index().get("dex") or {})
 154	        # Map name->id (int), keys lower
 155	        name_to_id = {k.lower(): int(v) for k, v in dex.items()}
 156	        ttk.Label(box4, text="Pokemon:").grid(row=0, column=0, sticky=tk.W, padx=4, pady=2)
 157	        self.starter_ac = AutoCompleteEntry(box4, name_to_id, width=30)
 158	        self.starter_ac.grid(row=0, column=1, sticky=tk.W, padx=4, pady=2)
 159	        # Attributes
 160	        ttk.Label(box4, text="abilityAttr:").grid(row=1, column=0, sticky=tk.W, padx=4, pady=2)
 161	        # abilityAttr presets via checkboxes
 162	        mask = load_ability_attr_mask() or {"ability_1": 1, "ability_2": 2, "ability_hidden": 4}
 163	        self.aa1 = tk.IntVar(value=1)
 164	        self.aa2 = tk.IntVar(value=1)
 165	        self.aah = tk.IntVar(value=1)
 166	        ttk.Checkbutton(box4, text="Ability 1", variable=self.aa1).grid(row=1, column=1, sticky=tk.W, padx=4)
 167	        ttk.Checkbutton(box4, text="Ability 2", variable=self.aa2).grid(row=1, column=2, sticky=tk.W, padx=4)
 168	        ttk.Checkbutton(box4, text="Hidden", variable=self.aah).grid(row=1, column=3, sticky=tk.W, padx=4)
 169	
 170	        ttk.Label(box4, text="passiveAttr:").grid(row=2, column=0, sticky=tk.W, padx=4, pady=2)
 171	        # Passive presets (UNLOCKED=1, ENABLED=2)
 172	        self.p_unlocked = tk.IntVar(value=1)
 173	        self.p_enabled = tk.IntVar(value=0)
 174	        ttk.Checkbutton(box4, text="Unlocked", variable=self.p_unlocked).grid(row=2, column=1, sticky=tk.W, padx=4)
 175	        ttk.Checkbutton(box4, text="Enabled", variable=self.p_enabled).grid(row=2, column=2, sticky=tk.W, padx=4)
 176	
 177	        ttk.Label(box4, text="valueReduction:").grid(row=3, column=0, sticky=tk.W, padx=4, pady=2)
 178	        self.starter_value_reduction = ttk.Entry(box4, width=8)
 179	        self.starter_value_reduction.insert(0, "0")
 180	        self.starter_value_reduction.grid(row=3, column=1, sticky=tk.W, padx=4, pady=2)
 181	
 182	        ttk.Button(box4, text="Apply Starter Attributes", command=self._safe(self._apply_starter_attrs)).grid(row=4, column=1, sticky=tk.W, padx=4, pady=4)
 183	        ttk.Button(box4, text="Unlock All Starters", command=self._safe(self._unlock_all_starters)).grid(row=4, column=2, sticky=tk.W, padx=4, pady=4)
 184	        ttk.Button(box4, text="Unlock Starter...", command=self._safe(self._unlock_starter_dialog)).grid(row=4, column=3, sticky=tk.W, padx=4, pady=4)
 185	
 186	        # Candies increment
 187	        ttk.Label(box4, text="Candies Δ:").grid(row=5, column=0, sticky=tk.W, padx=4, pady=2)
 188	        self.starter_candy_delta = ttk.Entry(box4, width=8)
 189	        self.starter_candy_delta.insert(0, "0")
 190	        self.starter_candy_delta.grid(row=5, column=1, sticky=tk.W, padx=4, pady=2)
 191	        ttk.Button(box4, text="Increment Candies", command=self._safe(self._inc_starter_candies)).grid(row=5, column=2, sticky=tk.W, padx=4, pady=2)
 192	
 193	        # Gacha tickets increment
 194	        ttk.Label(box4, text="Gacha Δ C/R/E/L:").grid(row=6, column=0, sticky=tk.W, padx=4, pady=2)
 195	        self.gacha_d0 = ttk.Entry(box4, width=5); self.gacha_d0.insert(0, "0"); self.gacha_d0.grid(row=6, column=1, sticky=tk.W, padx=2)
 196	        self.gacha_d1 = ttk.Entry(box4, width=5); self.gacha_d1.insert(0, "0"); self.gacha_d1.grid(row=6, column=1, sticky=tk.W, padx=2, columnspan=1)
 197	        self.gacha_d1.place(x=self.gacha_d0.winfo_x()+60, y=self.gacha_d0.winfo_y())
 198	        self.gacha_d2 = ttk.Entry(box4, width=5); self.gacha_d2.insert(0, "0")
 199	        self.gacha_d3 = ttk.Entry(box4, width=5); self.gacha_d3.insert(0, "0")
 200	        # Simpler layout vertically
 201	        ttk.Label(box4, text="Common Δ:").grid(row=7, column=0, sticky=tk.W, padx=4)
 202	        self.gacha_d0.grid(row=7, column=1, sticky=tk.W)
 203	        ttk.Label(box4, text="Rare Δ:").grid(row=8, column=0, sticky=tk.W, padx=4)
 204	        self.gacha_d1.grid(row=8, column=1, sticky=tk.W)
 205	        ttk.Label(box4, text="Epic Δ:").grid(row=9, column=0, sticky=tk.W, padx=4)
 206	        self.gacha_d2.grid(row=9, column=1, sticky=tk.W)
 207	        ttk.Label(box4, text="Legendary Δ:").grid(row=10, column=0, sticky=tk.W, padx=4)
 208	        self.gacha_d3.grid(row=10, column=1, sticky=tk.W)
 209	        ttk.Button(box4, text="Apply Gacha Δ", command=self._safe(self._apply_gacha_delta)).grid(row=11, column=1, sticky=tk.W, padx=4, pady=4)
 210	        # Passives unlock + Pokedex list
 211	        ttk.Button(box4, text="Unlock All Passives (mask=7)", command=self._safe(self._unlock_all_passives)).grid(row=11, column=2, sticky=tk.W, padx=4, pady=4)
 212	        ttk.Button(box4, text="Show Pokedex (names→IDs)", command=self._safe(self._pokedex_list)).grid(row=11, column=3, sticky=tk.W, padx=4, pady=4)
 213	        # Eggs
 214	        ttk.Button(box4, text="Hatch All Eggs After Next Fight", command=self._safe(self._hatch_eggs)).grid(row=12, column=1, sticky=tk.W, padx=4, pady=4)
 215	
 216	    def _build_console(self):
 217	        frm = ttk.LabelFrame(self, text="Console")
 218	        frm.pack(fill=tk.BOTH, expand=True, padx=8, pady=8)
 219	        self.console = tk.Text(frm, height=12)
 220	        self.console.pack(fill=tk.BOTH, expand=True)
 221	        # Busy progress bar
 222	        self.progress = ttk.Progressbar(frm, mode='indeterminate')
 223	        self.progress.pack(fill=tk.X, padx=4, pady=4)
 224	        self._busy_count = 0
 225	        # Enable mouse wheel scrolling on canvas and trees
 226	        def _on_mousewheel(event):
 227	            try:
 228	                delta = int(event.delta / 120)
 229	            except Exception:
 230	                delta = 1 if event.num == 4 else -1
 231	            widgets = [w for w in (self.actions_frame.master, self.slot_tree) if w.winfo_ismapped()]
 232	            for w in widgets:
 233	                if hasattr(w, 'yview_scroll'):
 234	                    w.yview_scroll(-delta, 'units')
 235	        self.bind_all('<MouseWheel>', _on_mousewheel)
 236	        self.bind_all('<Button-4>', _on_mousewheel)
 237	        self.bind_all('<Button-5>', _on_mousewheel)
 238	
 239	    # --- Helpers ---
 240	    def _log(self, text: str):
 241	        def append():
 242	            self.console.insert(tk.END, text + "\n")
 243	            self.console.see(tk.END)
 244	        self.after(0, append)
 245	
 246	    def _show_busy(self):
 247	        self._busy_count += 1
 248	        if self._busy_count == 1:
 249	            self.progress.start(10)
 250	
 251	    def _hide_busy(self):
 252	        self._busy_count = max(0, self._busy_count - 1)
 253	        if self._busy_count == 0:
 254	            self.progress.stop()
 255	
 256	    def _run_async(self, desc: str, work, on_done=None):
 257	        self._show_busy()
 258	        self._log(desc)
 259	        def runner():
 260	            err = None
 261	            try:
 262	                work()
 263	            except Exception as e:
 264	                err = e
 265	            def finish():
 266	                self._hide_busy()
 267	                if err:
 268	                    messagebox.showerror("Error", str(err))
 269	                    self._log(f"[ERROR] {err}")
 270	                elif on_done:
 271	                    on_done()
 272	            self.after(0, finish)
 273	        threading.Thread(target=runner, daemon=True).start()
 274	
 275	    def _safe(self, fn):
 276	        def wrapper():
 277	            if not self.editor:
 278	                messagebox.showwarning("Not logged in", "Please login first")
 279	                return
 280	            self._run_async("Working...", fn)
 281	        return wrapper
 282	
 283	    # --- Actions ---
 284	    def _new_user_dialog(self):
 285	        top = tk.Toplevel(self)
 286	        top.title("New User")
 287	        ttk.Label(top, text="Username:").pack(padx=6, pady=6)
 288	        ent = ttk.Entry(top)
 289	        ent.pack(padx=6, pady=6)
 290	        def ok():
 291	            user = sanitize_username(ent.get().strip())
 292	            vals = list_usernames()
 293	            vals.append(user)
 294	            self.user_combo["values"] = sorted(set(vals))
 295	            self.user_combo.set(user)
 296	            top.destroy()
 297	        ttk.Button(top, text="OK", command=ok).pack(pady=6)
 298	
 299	    def _login(self):
 300	        user = self.user_combo.get().strip()
 301	        if not user:
 302	            messagebox.showwarning("Missing", "Select or create a username")
 303	            return
 304	        pwd = self.pass_entry.get()
 305	        if not pwd:
 306	            messagebox.showwarning("Missing", "Enter password")
 307	            return
 308	        csid_input = self.csid_entry.get().strip()
 309	        def work():
 310	            api = PokerogueAPI(user, pwd)
 311	            api.login()
 312	            csid = csid_input or load_client_session_id() or None
 313	            if csid:
 314	                api.client_session_id = csid
 315	                try:
 316	                    save_client_session_id(csid)
 317	                    set_user_csid(user, csid)
 318	                except Exception:
 319	                    pass
 320	            self.api = api
 321	            self.editor = Editor(api)
 322	            self.username = user
 323	        def done():
 324	            self.status_var.set(f"Status: Logged in as {user}")
 325	            self._log(f"Logged in as {user}")
 326	            # Enable backup/restore and update backup status
 327	            try:
 328	                self.btn_backup.configure(state=tk.NORMAL)
 329	                self.btn_restore.configure(state=tk.NORMAL)
 330	            except Exception:
 331	                pass
 332	            self._update_backup_status()
 333	        self._run_async("Logging in...", work, done)
 334	
 335	    def _verify(self):
 336	        self.editor.system_verify()
 337	        self._log("System verify executed.")
 338	
 339	    def _dump_trainer(self):
 340	        self.editor.dump_trainer()
 341	        self._log(f"Dumped trainer to {trainer_save_path(self.username)}")
 342	
 343	    def _dump_slot_dialog(self):
 344	        slot = self._ask_slot()
 345	        if slot:
 346	            self.editor.dump_slot(slot)
 347	            self._log(f"Dumped slot {slot} to {slot_save_path(self.username, slot)}")
 348	    def _dump_slot_selected(self):
 349	        try:
 350	            slot = int(self.slot_var.get())
 351	        except Exception:
 352	            messagebox.showwarning("Invalid", "Invalid slot")
 353	            return
 354	        self.editor.dump_slot(slot)
 355	        self._log(f"Dumped slot {slot} to {slot_save_path(self.username, slot)}")
 356	
 357	    def _update_trainer(self):
 358	        if messagebox.askyesno("Confirm", "Update trainer from file?"):
 359	            try:
 360	                self.editor.update_trainer_from_file()
 361	                self._log("Trainer updated from file.")
 362	                messagebox.showinfo("Upload", "Trainer uploaded successfully.")
 363	            except Exception as e:
 364	                messagebox.showerror("Upload failed", str(e))
 365	
 366	    def _update_slot_dialog(self):
 367	        slot = self._ask_slot()
 368	        if slot and messagebox.askyesno("Confirm", f"Update slot {slot} from file?"):
 369	            self.editor.update_slot_from_file(slot)
 370	            self._log(f"Slot {slot} updated from file.")
 371	    def _update_slot_selected(self):
 372	        try:
 373	            slot = int(self.slot_var.get())
 374	        except Exception:
 375	            messagebox.showwarning("Invalid", "Invalid slot")
 376	            return
 377	        if messagebox.askyesno("Confirm", f"Update slot {slot} from file?"):
 378	            try:
 379	                self.editor.update_slot_from_file(slot)
 380	                self._log(f"Slot {slot} updated from file.")
 381	                messagebox.showinfo("Upload", f"Slot {slot} uploaded successfully.")
 382	            except Exception as e:
 383	                messagebox.showerror("Upload failed", str(e))
 384	                return
 385	
 386	    def _hatch_eggs(self):
 387	        try:
 388	            self.editor.hatch_all_eggs()
 389	            self._log("Eggs set to hatch after next fight.")
 390	            messagebox.showinfo("Eggs", "All eggs will hatch after the next fight.")
 391	        except Exception as e:
 392	            messagebox.showerror("Hatch failed", str(e))
 393	
 394	    def _open_local_dump_dialog(self):
 395	        # Opens trainer.json or slot N.json in the OS default editor
 396	        from rogueeditor.utils import trainer_save_path, slot_save_path
 397	        if not self.username:
 398	            messagebox.showwarning("Missing", "Please log in/select a user first.")
 399	            return
 400	        top = tk.Toplevel(self)
 401	        top.title("Open Local Dump")
 402	        ttk.Label(top, text="Open which file?").grid(row=0, column=0, columnspan=3, padx=6, pady=6, sticky=tk.W)
 403	        choice = tk.StringVar(value='trainer')
 404	        ttk.Radiobutton(top, text="Trainer (trainer.json)", variable=choice, value='trainer').grid(row=1, column=0, sticky=tk.W, padx=6)
 405	        ttk.Radiobutton(top, text="Slot (slot N.json)", variable=choice, value='slot').grid(row=2, column=0, sticky=tk.W, padx=6)
 406	        ttk.Label(top, text="Slot:").grid(row=2, column=1, sticky=tk.E)
 407	        slot_var = tk.StringVar(value=self.slot_var.get())
 408	        ttk.Combobox(top, textvariable=slot_var, values=["1","2","3","4","5"], width=4, state='readonly').grid(row=2, column=2, sticky=tk.W)
 409	
 410	        def open_path(path: str):
 411	            if sys.platform.startswith('win'):
 412	                try:
 413	                    os.startfile(path)  # type: ignore[attr-defined]
 414	                except OSError as e:
 415	                    messagebox.showerror("Open failed", str(e))
 416	            elif sys.platform == 'darwin':
 417	                try:
 418	                    subprocess.run(['open', path], check=False)
 419	                except Exception as e:
 420	                    messagebox.showerror("Open failed", str(e))
 421	            else:
 422	                try:
 423	                    subprocess.run(['xdg-open', path], check=False)
 424	                except Exception as e:
 425	                    messagebox.showerror("Open failed", str(e))
 426	
 427	        def do_open():
 428	            target = choice.get()
 429	            if target == 'trainer':
 430	                p = trainer_save_path(self.username)
 431	            else:
 432	                try:
 433	                    s = int(slot_var.get())
 434	                except Exception:
 435	                    messagebox.showwarning("Invalid", "Invalid slot")
 436	                    return
 437	                p = slot_save_path(self.username, s)
 438	            if not os.path.exists(p):
 439	                messagebox.showwarning("Not found", f"{p} does not exist. Dump first.")
 440	                return
 441	            open_path(p)
 442	            top.destroy()
 443	
 444	        ttk.Button(top, text="Open", command=do_open).grid(row=3, column=0, padx=6, pady=10, sticky=tk.W)
 445	        ttk.Button(top, text="Close", command=top.destroy).grid(row=3, column=1, padx=6, pady=10, sticky=tk.W)
 446	
 447	    def _on_slot_select(self, event=None):
 448	        sel = self.slot_tree.selection()
 449	        if not sel:
 450	            return
 451	        item = self.slot_tree.item(sel[0])
 452	        values = item.get('values') or []
 453	        if values:
 454	            self.slot_var.set(str(values[0]))
 455	
 456	    def _refresh_slots(self):
 457	        import time
 458	        from rogueeditor.utils import slot_save_path
 459	        def work():
 460	            rows = []
 461	            for i in range(1, 6):
 462	                party_ct = '-'
 463	                playtime = '-'
 464	                empty = False
 465	                try:
 466	                    data = self.api.get_slot(i)
 467	                    party = data.get('party') or []
 468	                    party_ct = len(party)
 469	                    pt = data.get('playTime') or 0
 470	                    h = int(pt) // 3600
 471	                    m = (int(pt) % 3600) // 60
 472	                    s = int(pt) % 60
 473	                    playtime = f"{h:02d}:{m:02d}:{s:02d}"
 474	                    empty = (party_ct == 0 and pt == 0)
 475	                except Exception:
 476	                    empty = True
 477	                    party_ct = 0
 478	                    playtime = '-'
 479	                # Local dump time
 480	                local = '-'
 481	                p = slot_save_path(self.username, i)
 482	                if os.path.exists(p):
 483	                    ts = os.path.getmtime(p)
 484	                    local = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(ts))
 485	                rows.append((i, party_ct, playtime, local, empty))
 486	            def update():
 487	                for r in self.slot_tree.get_children():
 488	                    self.slot_tree.delete(r)
 489	                for (slot, party_ct, playtime, local, empty) in rows:
 490	                    tags = ('empty',) if empty else ()
 491	                    self.slot_tree.insert('', 'end', values=(slot, party_ct, playtime, local), tags=tags)
 492	            self.after(0, update)
 493	        self._run_async("Loading slots...", work)
 494	
 495	    def _backup(self):
 496	        def work():
 497	            path = self.editor.backup_all()
 498	            self._log(f"Backup created: {path}")
 499	        def done():
 500	            self._update_backup_status()
 501	        self._run_async("Creating backup...", work, done)
 502	
 503	    def _restore_dialog(self):
 504	        base = os.path.join("Source", "saves", self.username, "backups")
 505	        if not os.path.isdir(base):
 506	            messagebox.showinfo("No backups", "No backups found.")
 507	            return
 508	        dirs = sorted([d for d in os.listdir(base) if os.path.isdir(os.path.join(base, d))])
 509	        if not dirs:
 510	            messagebox.showinfo("No backups", "No backups found.")
 511	            return
 512	        top = tk.Toplevel(self)
 513	        top.title("Select Backup")
 514	        frm = ttk.Frame(top)
 515	        frm.pack(fill=tk.BOTH, expand=True)
 516	        lb = tk.Listbox(frm, height=12)
 517	        sb = ttk.Scrollbar(frm, orient='vertical', command=lb.yview)
 518	        lb.configure(yscrollcommand=sb.set)
 519	        lb.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=6, pady=6)
 520	        sb.pack(side=tk.RIGHT, fill=tk.Y)
 521	        for d in dirs:
 522	            lb.insert(tk.END, d)
 523	        def restore():
 524	            sel = lb.curselection()
 525	            if not sel:
 526	                return
 527	            backup_dir = os.path.join(base, lb.get(sel[0]))
 528	            # Options dialog for scope
 529	            scope = tk.StringVar(value='all')
 530	            opt = tk.Toplevel(self)
 531	            opt.title("Restore Options")
 532	            ttk.Radiobutton(opt, text="Restore ALL (trainer + slots)", variable=scope, value='all').grid(row=0, column=0, sticky=tk.W, padx=6, pady=4)
 533	            ttk.Radiobutton(opt, text="Restore Trainer ONLY", variable=scope, value='trainer').grid(row=1, column=0, sticky=tk.W, padx=6, pady=4)
 534	            ttk.Radiobutton(opt, text="Restore Specific Slot", variable=scope, value='slot').grid(row=2, column=0, sticky=tk.W, padx=6, pady=4)
 535	            ttk.Label(opt, text="Slot:").grid(row=2, column=1, sticky=tk.E)
 536	            slot_var = tk.StringVar(value='1')
 537	            slot_cb = ttk.Combobox(opt, textvariable=slot_var, values=["1","2","3","4","5"], width=4, state='readonly')
 538	            slot_cb.grid(row=2, column=2, sticky=tk.W)
 539	            def do_restore():
 540	                choice = scope.get()
 541	                name = lb.get(sel[0])
 542	                if not messagebox.askyesno("Confirm", f"Restore ({choice}) from {name}? This overwrites server state."):
 543	                    return
 544	                if choice == 'all':
 545	                    self._run_async(
 546	                        "Restoring backup (all)...",
 547	                        lambda: self.editor.restore_from_backup(backup_dir),
 548	                        lambda: self._log(f"Restored backup {backup_dir} (all)")
 549	                    )
 550	                elif choice == 'trainer':
 551	                    def work():
 552	                        from rogueeditor.utils import load_json
 553	                        tp = os.path.join(backup_dir, 'trainer.json')
 554	                        if os.path.exists(tp):
 555	                            data = load_json(tp)
 556	                            self.api.update_trainer(data)
 557	                    self._run_async("Restoring backup (trainer)...", work, lambda: self._log(f"Restored trainer from {backup_dir}"))
 558	                else:
 559	                    try:
 560	                        s = int(slot_var.get())
 561	                    except Exception:
 562	                        messagebox.showwarning("Invalid", "Invalid slot")
 563	                        return
 564	                    def work():
 565	                        from rogueeditor.utils import load_json
 566	                        sp = os.path.join(backup_dir, f"slot {s}.json")
 567	                        if os.path.exists(sp):
 568	                            data = load_json(sp)
 569	                            self.api.update_slot(s, data)
 570	                    self._run_async("Restoring backup (slot)...", work, lambda: self._log(f"Restored slot {s} from {backup_dir}"))
 571	                opt.destroy(); top.destroy()
 572	            ttk.Button(opt, text="Restore", command=do_restore).grid(row=3, column=0, columnspan=3, pady=8)
 573	        def delete_backup():
 574	            sel = lb.curselection()
 575	            if not sel:
 576	                return
 577	            target = lb.get(sel[0])
 578	            backup_dir = os.path.join(base, target)
 579	            dirs2 = sorted([d for d in os.listdir(base) if os.path.isdir(os.path.join(base, d))])
 580	            is_last = len(dirs2) == 1
 581	            is_latest = (dirs2 and target == dirs2[-1])
 582	            msg = f"Delete backup {target}?"
 583	            if is_last:
 584	                msg += "\nWARNING: This is the last backup."
 585	            elif is_latest:
 586	                msg += "\nWarning: This is the most recent backup."
 587	            if not messagebox.askyesno("Confirm Delete", msg):
 588	                return
 589	            import shutil
 590	            try:
 591	                shutil.rmtree(backup_dir)
 592	                self._log(f"Deleted backup {target}")
 593	                lb.delete(sel[0])
 594	                self._update_backup_status()
 595	            except Exception as e:
 596	                messagebox.showerror("Delete failed", str(e))
 597	        btns = ttk.Frame(top)
 598	        btns.pack(fill=tk.X, padx=6, pady=6)
 599	        ttk.Button(btns, text="Restore", command=restore).pack(side=tk.LEFT, padx=4)
 600	        ttk.Button(btns, text="Delete", command=delete_backup).pack(side=tk.LEFT, padx=4)
 601	
 602	    def _update_backup_status(self):
 603	        try:
 604	            from rogueeditor.utils import user_save_dir
 605	            if not self.username:
 606	                self.backup_status_var.set("Last backup: none")
 607	                return
 608	            base = os.path.join(user_save_dir(self.username), "backups")
 609	            if not os.path.isdir(base):
 610	                self.backup_status_var.set("Last backup: none")
 611	                return
 612	            dirs = sorted([d for d in os.listdir(base) if os.path.isdir(os.path.join(base, d))])
 613	            self.backup_status_var.set(f"Last backup: {dirs[-1]}") if dirs else self.backup_status_var.set("Last backup: none")
 614	        except Exception:
 615	            self.backup_status_var.set("Last backup: unknown")
 616	
 617	    def _restore_dialog2(self):
 618	        from rogueeditor.utils import user_save_dir, load_json
 619	        base = os.path.join(user_save_dir(self.username or ""), "backups")
 620	        if not os.path.isdir(base):
 621	            messagebox.showinfo("No backups", "No backups found.")
 622	            return
 623	        dirs = sorted([d for d in os.listdir(base) if os.path.isdir(os.path.join(base, d))])
 624	        if not dirs:
 625	            messagebox.showinfo("No backups", "No backups found.")
 626	            return
 627	        top = tk.Toplevel(self)
 628	        top.title("Select Backup")
 629	        frm = ttk.Frame(top)
 630	        frm.pack(fill=tk.BOTH, expand=True)
 631	        lb = tk.Listbox(frm, height=12)
 632	        sb = ttk.Scrollbar(frm, orient='vertical', command=lb.yview)
 633	        lb.configure(yscrollcommand=sb.set)
 634	        lb.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=6, pady=6)
 635	        sb.pack(side=tk.RIGHT, fill=tk.Y)
 636	        for d in dirs:
 637	            lb.insert(tk.END, d)
 638	        def restore():
 639	            sel = lb.curselection()
 640	            if not sel:
 641	                return
 642	            name = lb.get(sel[0])
 643	            backup_dir = os.path.join(base, name)
 644	            scope = tk.StringVar(value='all')
 645	            opt = tk.Toplevel(self)
 646	            opt.title("Restore Options")
 647	            ttk.Radiobutton(opt, text="Restore ALL (trainer + slots)", variable=scope, value='all').grid(row=0, column=0, sticky=tk.W, padx=6, pady=4)
 648	            ttk.Radiobutton(opt, text="Restore Trainer ONLY", variable=scope, value='trainer').grid(row=1, column=0, sticky=tk.W, padx=6, pady=4)
 649	            ttk.Radiobutton(opt, text="Restore Specific Slot", variable=scope, value='slot').grid(row=2, column=0, sticky=tk.W, padx=6, pady=4)
 650	            ttk.Label(opt, text="Slot:").grid(row=2, column=1, sticky=tk.E)
 651	            slot_var = tk.StringVar(value='1')
 652	            slot_cb = ttk.Combobox(opt, textvariable=slot_var, values=["1","2","3","4","5"], width=4, state='readonly')
 653	            slot_cb.grid(row=2, column=2, sticky=tk.W)
 654	            def do_restore():
 655	                choice = scope.get()
 656	                if not messagebox.askyesno("Confirm", f"Restore ({choice}) from {name}? This overwrites server state."):
 657	                    return
 658	                if choice == 'all':
 659	                    self._run_async("Restoring backup (all)...", lambda: self.editor.restore_from_backup(backup_dir), lambda: self._log(f"Restored backup {name} (all)"))
 660	                elif choice == 'trainer':
 661	                    def work():
 662	                        tp = os.path.join(backup_dir, 'trainer.json')
 663	                        if os.path.exists(tp):
 664	                            data = load_json(tp)
 665	                            self.api.update_trainer(data)
 666	                    self._run_async("Restoring trainer...", work, lambda: self._log(f"Restored trainer from {name}"))
 667	                else:
 668	                    try:
 669	                        s = int(slot_var.get())
 670	                    except Exception:
 671	                        messagebox.showwarning("Invalid", "Invalid slot")
 672	                        return
 673	                    def work():
 674	                        sp = os.path.join(backup_dir, f"slot {s}.json")
 675	                        if os.path.exists(sp):
 676	                            data = load_json(sp)
 677	                            self.api.update_slot(s, data)
 678	                    self._run_async("Restoring slot...", work, lambda: self._log(f"Restored slot {s} from {name}"))
 679	                opt.destroy(); top.destroy()
 680	            ttk.Button(opt, text="Restore", command=do_restore).grid(row=3, column=0, columnspan=3, pady=8)
 681	        def delete_backup():
 682	            sel = lb.curselection()
 683	            if not sel:
 684	                return
 685	            target = lb.get(sel[0])
 686	            bdir = os.path.join(base, target)
 687	            d2 = sorted([d for d in os.listdir(base) if os.path.isdir(os.path.join(base, d))])
 688	            is_last = (len(d2) == 1)
 689	            is_latest = (d2 and target == d2[-1])
 690	            msg = f"Delete backup {target}?"
 691	            if is_last:
 692	                msg += "\nWARNING: This is the last backup."
 693	            elif is_latest:
 694	                msg += "\nWarning: This is the most recent backup."
 695	            if not messagebox.askyesno("Confirm Delete", msg):
 696	                return
 697	            import shutil
 698	            try:
 699	                shutil.rmtree(bdir)
 700	                self._log(f"Deleted backup {target}")
 701	                lb.delete(sel[0])
 702	                self._update_backup_status()
 703	            except Exception as e:
 704	                messagebox.showerror("Delete failed", str(e))
 705	        btns = ttk.Frame(top)
 706	        btns.pack(fill=tk.X, padx=6, pady=6)
 707	        ttk.Button(btns, text="Restore", command=restore).pack(side=tk.LEFT, padx=4)
 708	        ttk.Button(btns, text="Delete", command=delete_backup).pack(side=tk.LEFT, padx=4)
 709	
 710	    def _upload_local_dialog(self):
 711	        # A simple dialog to upload trainer.json and/or selected slot file to server.
 712	        from rogueeditor.utils import trainer_save_path, slot_save_path, load_json
 713	        top = tk.Toplevel(self)
 714	        top.title("Upload Local Changes")
 715	        ttk.Label(top, text="Choose what to upload to the server:").grid(row=0, column=0, columnspan=3, padx=6, pady=6, sticky=tk.W)
 716	        tr_var = tk.BooleanVar(value=True)
 717	        sl_var = tk.BooleanVar(value=True)
 718	        ttk.Checkbutton(top, text="Trainer (trainer.json)", variable=tr_var).grid(row=1, column=0, sticky=tk.W, padx=6)
 719	        ttk.Label(top, text="Slot:").grid(row=2, column=0, sticky=tk.E, padx=6)
 720	        slot_var = tk.StringVar(value=self.slot_var.get())
 721	        ttk.Combobox(top, textvariable=slot_var, values=["1","2","3","4","5"], width=4, state='readonly').grid(row=2, column=1, sticky=tk.W)
 722	        ttk.Checkbutton(top, text="Upload slot file (slot N.json)", variable=sl_var).grid(row=2, column=2, sticky=tk.W, padx=6)
 723	        def do_upload():
 724	            # Trainer
 725	            if tr_var.get():
 726	                try:
 727	                    tp = trainer_save_path(self.username)
 728	                    if os.path.exists(tp):
 729	                        data = load_json(tp)
 730	                        self.api.update_trainer(data)
 731	                        self._log(f"Uploaded trainer from {tp}")
 732	                    else:
 733	                        messagebox.showwarning("Missing", f"{tp} not found")
 734	                except Exception as e:
 735	                    messagebox.showerror("Trainer upload failed", str(e))
 736	                    return
 737	            # Slot
 738	            if sl_var.get():
 739	                try:
 740	                    s = int(slot_var.get())
 741	                except Exception:
 742	                    messagebox.showwarning("Invalid", "Invalid slot")
 743	                    return
 744	                sp = slot_save_path(self.username, s)
 745	                if os.path.exists(sp):
 746	                    try:
 747	                        data = load_json(sp)
 748	                        self.api.update_slot(s, data)
 749	                        self._log(f"Uploaded slot {s} from {sp}")
 750	                    except Exception as e:
 751	                        messagebox.showerror("Slot upload failed", str(e))
 752	                        return
 753	                else:
 754	                    messagebox.showwarning("Missing", f"{sp} not found")
 755	                    return
 756	            messagebox.showinfo("Upload", "Upload completed.")
 757	            top.destroy()
 758	        ttk.Button(top, text="Upload", command=do_upload).grid(row=3, column=0, padx=6, pady=10, sticky=tk.W)
 759	        ttk.Button(top, text="Close", command=top.destroy).grid(row=3, column=1, padx=6, pady=10, sticky=tk.W)
 760	
 761	    def _analyze_team_dialog(self):
 762	        try:
 763	            slot = int(self.slot_var.get())
 764	        except Exception:
 765	            slot = self._ask_slot()
 766	        if slot:
 767	            self.editor.analyze_team(slot)
 768	            self._log(f"Analyzed team for slot {slot}")
 769	
 770	    def _analyze_run_conditions(self):
 771	        try:
 772	            slot = int(self.slot_var.get())
 773	        except Exception:
 774	            slot = self._ask_slot()
 775	        if slot:
 776	            self.editor.analyze_run_conditions(slot)
 777	            self._log(f"Analyzed run conditions for slot {slot}")
 778	
 779	    def _edit_run_weather(self):
 780	        try:
 781	            slot = int(self.slot_var.get())
 782	        except Exception:
 783	            slot = self._ask_slot()
 784	        if not slot:
 785	            return
 786	        # Fetch session and find weather key
 787	        data = self.api.get_slot(slot)
 788	        wkey = None
 789	        for k in ("weather", "weatherType", "currentWeather"):
 790	            if k in data:
 791	                wkey = k
 792	                break
 793	        if not wkey:
 794	            messagebox.showinfo("Run Weather", "Weather field not found in session.")
 795	            return
 796	        from rogueeditor.catalog import load_weather_catalog
 797	        n2i, i2n = load_weather_catalog()
 798	        top = tk.Toplevel(self)
 799	        top.title(f"Edit Run Weather - Slot {slot}")
 800	        ttk.Label(top, text="Weather:").grid(row=0, column=0, padx=6, pady=6)
 801	        items = [f"{name} ({iid})" for name, iid in sorted(n2i.items(), key=lambda kv: kv[0])]
 802	        var = tk.StringVar()
 803	        cb = ttk.Combobox(top, values=items, textvariable=var, width=28)
 804	        cur = data.get(wkey)
 805	        cur_disp = i2n.get(int(cur), str(cur)) if isinstance(cur, int) else str(cur)
 806	        var.set(f"{cur_disp} ({cur})")
 807	        cb.grid(row=0, column=1, padx=6, pady=6)
 808	        def do_apply():
 809	            text = var.get().strip()
 810	            val = None
 811	            if text.endswith(')') and '(' in text:
 812	                try:
 813	                    val = int(text.rsplit('(',1)[1].rstrip(')'))
 814	                except Exception:
 815	                    val = None
 816	            if val is None:
 817	                key = text.strip().lower().replace(' ', '_')
 818	                val = n2i.get(key)
 819	            if not isinstance(val, int):
 820	                messagebox.showwarning('Invalid', 'Select a valid weather')
 821	                return
 822	            data[wkey] = val
 823	            from rogueeditor.utils import slot_save_path, dump_json
 824	            p = slot_save_path(self.api.username, slot)
 825	            dump_json(p, data)
 826	            self._log(f"Updated weather to {val}; wrote {p}")
 827	            if messagebox.askyesno('Upload', 'Upload changes to server?'):
 828	                try:
 829	                    self.api.update_slot(slot, data)
 830	                    messagebox.showinfo('Uploaded', 'Server updated successfully')
 831	                except Exception as e:
 832	                    messagebox.showerror('Upload failed', str(e))
 833	            top.destroy()
 834	        ttk.Button(top, text='Apply', command=do_apply).grid(row=1, column=1, padx=6, pady=6, sticky=tk.W)
 835	
 836	    def _edit_team_dialog(self):
 837	        try:
 838	            slot = int(self.slot_var.get())
 839	        except Exception:
 840	            slot = self._ask_slot()
 841	        if slot:
 842	            TeamEditorDialog(self, self.api, self.editor, slot)
 843	            self._log(f"Opened team editor for slot {slot}")
 844	
 845	    def _list_mods_dialog(self):
 846	        slot = self._ask_slot()
 847	        if slot:
 848	            self.editor.list_modifiers(slot)
 849	            self._log(f"Listed modifiers for slot {slot}")
 850	
 851	    def _open_mod_mgr(self):
 852	        try:
 853	            slot = int(self.slot_var.get())
 854	        except Exception:
 855	            slot = self._ask_slot()
 856	        if slot:
 857	            ModifiersManagerDialog(self, self.api, self.editor, slot)
 858	            self._log(f"Opened modifiers manager for slot {slot}")
 859	
 860	    def _unlock_all_starters(self):
 861	        # Strong warning + typed confirmation
 862	        top = tk.Toplevel(self)
 863	        top.title('Unlock ALL Starters - Confirmation')
 864	        msg = (
 865	            'WARNING:\n\n'
 866	            'This action will UNLOCK ALL STARTERS with perfect IVs and shiny variants.\n'
 867	            'It may significantly impact or ruin your player experience.\n\n'
 868	            'To confirm, type the phrase exactly and check the acknowledgment:'
 869	        )
 870	        ttk.Label(top, text=msg, justify=tk.LEFT, wraplength=520).grid(row=0, column=0, columnspan=2, padx=8, pady=8, sticky=tk.W)
 871	        expected = 'UNLOCK ALL STARTERS'
 872	        ttk.Label(top, text=f"Type: {expected}").grid(row=1, column=0, padx=8, pady=4, sticky=tk.W)
 873	        phrase_var = tk.StringVar()
 874	        ttk.Entry(top, textvariable=phrase_var, width=34).grid(row=1, column=1, padx=8, pady=4, sticky=tk.W)
 875	        ack_var = tk.IntVar(value=0)
 876	        ttk.Checkbutton(top, text='I accept the risks and understand this is final.', variable=ack_var).grid(row=2, column=0, columnspan=2, padx=8, pady=6, sticky=tk.W)
 877	        def proceed():
 878	            text = (phrase_var.get() or '').strip()
 879	            if text != expected:
 880	                messagebox.showwarning('Not confirmed', 'Phrase does not match. Action cancelled.')
 881	                return
 882	            if not ack_var.get():
 883	                messagebox.showwarning('Not confirmed', 'Please acknowledge the risks to proceed.')
 884	                return
 885	            try:
 886	                self.editor.unlock_all_starters()
 887	                self._log('All starters unlocked (perfect IVs, shinies).')
 888	                messagebox.showinfo('Completed', 'All starters unlocked successfully.')
 889	                top.destroy()
 890	            except Exception as e:
 891	                messagebox.showerror('Failed', str(e))
 892	        ttk.Button(top, text='Cancel', command=top.destroy).grid(row=3, column=0, padx=8, pady=10, sticky=tk.W)
 893	        ttk.Button(top, text='Proceed', command=proceed).grid(row=3, column=1, padx=8, pady=10, sticky=tk.E)
 894	
 895	    def _unlock_all_passives(self):
 896	        # Use the selected starter in the autocomplete
 897	        ident = self.starter_ac.get().strip()
 898	        if not ident:
 899	            messagebox.showwarning('Missing', 'Select a Pokemon in the Starters section first.')
 900	            return
 901	        if not messagebox.askyesno('Confirm', f'Unlock all passives for {ident}?'):
 902	            return
 903	        try:
 904	            self.editor.unlock_all_passives(ident, mask=7)
 905	            self._log(f'Unlocked all passives for {ident}.')
 906	        except Exception as e:
 907	            messagebox.showerror('Failed', str(e))
 908	
 909	    def _pokedex_list(self):
 910	        try:
 911	            self.editor.pokedex_list()
 912	            self._log('Listed Pokedex names with IDs in console.')
 913	        except Exception as e:
 914	            messagebox.showerror('Failed', str(e))
 915	
 916	    def _unlock_starter_dialog(self):
 917	        # Dialog to pick a starter and set unlock properties
 918	        from rogueeditor.utils import load_pokemon_index
 919	        from rogueeditor.catalog import load_move_catalog, load_ability_attr_mask
 920	        index = load_pokemon_index()
 921	        dex = (index.get('dex') or {})
 922	        # Build display mapping like "#001 Bulbasaur" -> id
 923	        def _pretty(n: str) -> str:
 924	            return n.replace('_', ' ').title()
 925	        disp_to_id: dict[str, int] = {}
 926	        for name, vid in dex.items():
 927	            try:
 928	                i = int(vid)
 929	            except Exception:
 930	                continue
 931	            disp = f"#{i:03d} {_pretty(name)}"
 932	            disp_to_id[disp] = i
 933	        # Select starter via catalog dialog
 934	        sid = CatalogSelectDialog.select(self, disp_to_id, 'Select Starter')
 935	        if sid is None:
 936	            return
 937	        # Resolve display name
 938	        sel_disp = None
 939	        for n, i in disp_to_id.items():
 940	            if i == sid:
 941	                sel_disp = n
 942	                break
 943	        # Build dialog
 944	        top = tk.Toplevel(self)
 945	        top.title(f"Unlock Starter - {sel_disp or ('#%03d' % sid)}")
 946	        ttk.Label(top, text=f"Selected: {sel_disp or ('#%03d' % sid)}").grid(row=0, column=0, columnspan=6, sticky=tk.W, padx=6, pady=6)
 947	
 948	        # Options
 949	        perfect_iv = tk.IntVar(value=1)
 950	        shiny_var = tk.IntVar(value=0)
 951	        ttk.Checkbutton(top, text='Perfect IVs (31s)', variable=perfect_iv).grid(row=1, column=0, sticky=tk.W, padx=6)
 952	        ttk.Checkbutton(top, text='Shiny', variable=shiny_var).grid(row=1, column=1, sticky=tk.W, padx=6)
 953	
 954	        ttk.Label(top, text='Seen:').grid(row=2, column=0, sticky=tk.E)
 955	        seen_e = ttk.Entry(top, width=6); seen_e.insert(0, '10'); seen_e.grid(row=2, column=1, sticky=tk.W)
 956	        ttk.Label(top, text='Caught:').grid(row=2, column=2, sticky=tk.E)
 957	        caught_e = ttk.Entry(top, width=6); caught_e.insert(0, '5'); caught_e.grid(row=2, column=3, sticky=tk.W)
 958	        ttk.Label(top, text='Hatched:').grid(row=2, column=4, sticky=tk.E)
 959	        hatched_e = ttk.Entry(top, width=6); hatched_e.insert(0, '0'); hatched_e.grid(row=2, column=5, sticky=tk.W)
 960	
 961	        # StarterData properties
 962	        ttk.Label(top, text='Candy Count:').grid(row=3, column=0, sticky=tk.E)
 963	        candy_e = ttk.Entry(top, width=8); candy_e.insert(0, '0'); candy_e.grid(row=3, column=1, sticky=tk.W)
 964	        ttk.Label(top, text='valueReduction:').grid(row=3, column=2, sticky=tk.E)
 965	        vr_e = ttk.Entry(top, width=8); vr_e.insert(0, '0'); vr_e.grid(row=3, column=3, sticky=tk.W)
 966	
 967	        # abilityAttr mask
 968	        mask = load_ability_attr_mask() or {"ability_1": 1, "ability_2": 2, "ability_hidden": 4}
 969	        aa1 = tk.IntVar(value=1); aa2 = tk.IntVar(value=1); aah = tk.IntVar(value=1)
 970	        ttk.Label(top, text='abilityAttr:').grid(row=4, column=0, sticky=tk.W, padx=6)
 971	        ttk.Checkbutton(top, text='Ability 1', variable=aa1).grid(row=4, column=1, sticky=tk.W)
 972	        ttk.Checkbutton(top, text='Ability 2', variable=aa2).grid(row=4, column=2, sticky=tk.W)
 973	        ttk.Checkbutton(top, text='Hidden', variable=aah).grid(row=4, column=3, sticky=tk.W)
 974	
 975	        # passiveAttr flags
 976	        ttk.Label(top, text='passiveAttr:').grid(row=5, column=0, sticky=tk.W, padx=6)
 977	        p_unlocked = tk.IntVar(value=1); p_enabled = tk.IntVar(value=0)
 978	        ttk.Checkbutton(top, text='Unlocked', variable=p_unlocked).grid(row=5, column=1, sticky=tk.W)
 979	        ttk.Checkbutton(top, text='Enabled', variable=p_enabled).grid(row=5, column=2, sticky=tk.W)
 980	
 981	        # Moveset (optional)
 982	        ttk.Label(top, text='Starter Moves (optional):').grid(row=6, column=0, sticky=tk.W, padx=6)
 983	        move_n2i, move_i2n = load_move_catalog()
 984	        move_acs = []
 985	        for i in range(4):
 986	            ac = AutoCompleteEntry(top, move_n2i, width=24)
 987	            ac.grid(row=6+i, column=1, sticky=tk.W, padx=4, pady=2)
 988	            ttk.Button(top, text='Pick', command=lambda j=i: self._pick_from_catalog(move_acs[j], move_n2i, f'Select Move {j+1}')).grid(row=6+i, column=2, sticky=tk.W)
 989	            move_acs.append(ac)
 990	
 991	        def do_apply():
 992	            try:
 993	                seen = int(seen_e.get().strip() or '0')
 994	                caught = int(caught_e.get().strip() or '0')
 995	                hatched = int(hatched_e.get().strip() or '0')
 996	                candy = int(candy_e.get().strip() or '0')
 997	                vr = int(vr_e.get().strip() or '0')
 998	            except ValueError:
 999	                messagebox.showwarning('Invalid', 'Counts and valueReduction must be integers')
1000	                return
1001	            # Compose trainer update
1002	            data = self.api.get_trainer()
1003	            dex_id = str(sid)
1004	            # dexData
1005	            shiny_attr = 255 if shiny_var.get() else 253
1006	            dex_entry = {
1007	                "seenAttr": 479,
1008	                "caughtAttr": shiny_attr,
1009	                "natureAttr": 67108862,
1010	                "seenCount": max(0, seen),
1011	                "caughtCount": max(0, caught),
1012	                "hatchedCount": max(0, hatched),
1013	            }
1014	            if perfect_iv.get():
1015	                dex_entry["ivs"] = [31, 31, 31, 31, 31, 31]
1016	            data.setdefault('dexData', {})[dex_id] = {**(data.get('dexData', {}).get(dex_id) or {}), **dex_entry}
1017	            # starterData
1018	            abil_mask = (mask.get('ability_1',1) if aa1.get() else 0) | (mask.get('ability_2',2) if aa2.get() else 0) | (mask.get('ability_hidden',4) if aah.get() else 0)
1019	            passive = (1 if p_unlocked.get() else 0) | (2 if p_enabled.get() else 0)
1020	            moves = []
1021	            for ac in move_acs:
1022	                mid = ac.get_id()
1023	                if isinstance(mid, int):
1024	                    moves.append(mid)
1025	            starter_entry = {
1026	                "moveset": moves or None,
1027	                "eggMoves": 15,
1028	                "candyCount": max(0, candy),
1029	                "abilityAttr": abil_mask or 7,
1030	                "passiveAttr": passive,
1031	                "valueReduction": max(0, vr),
1032	            }
1033	            data.setdefault('starterData', {})[dex_id] = {**(data.get('starterData', {}).get(dex_id) or {}), **starter_entry}
1034	            try:
1035	                self.api.update_trainer(data)
1036	                messagebox.showinfo('Starter', 'Starter unlocked/updated successfully.')
1037	                self._log(f"Updated starter dex {dex_id}")
1038	                top.destroy()
1039	            except Exception as e:
1040	                messagebox.showerror('Failed', str(e))
1041	
1042	        ttk.Button(top, text='Apply', command=do_apply).grid(row=10, column=1, padx=6, pady=8, sticky=tk.W)
1043	        def do_apply_and_upload():
1044	            if not messagebox.askyesno('Confirm Unlock', 'This will unlock the starter with the selected properties and is final. Proceed?'):
1045	                return
1046	            do_apply()
1047	        ttk.Button(top, text='Apply and Upload', command=do_apply_and_upload).grid(row=10, column=2, padx=6, pady=8, sticky=tk.W)
1048	        ttk.Button(top, text='Close', command=top.destroy).grid(row=10, column=3, padx=6, pady=8, sticky=tk.W)
1049	
1050	    def _add_item_dialog(self):
1051	        slot = self._ask_slot()
1052	        if not slot:
1053	            return
1054	        idx = self._ask_int("Team slot (1-5): ")
1055	        if not idx:
1056	            return
1057	        item = self._ask_str("Item type (e.g., WIDE_LENS, BERRY, BASE_STAT_BOOSTER): ")
1058	        if not item:
1059	            return
1060	        if item.strip().upper() == "BASE_STAT_BOOSTER":
1061	            # Ask stat
1062	            from rogueeditor.catalog import load_stat_catalog
1063	            n2i, i2n = load_stat_catalog()
1064	            top = tk.Toplevel(self)
1065	            top.title("Select Stat")
1066	            ttk.Label(top, text="Stat (id or name):").pack(padx=6, pady=6)
1067	            ac = AutoCompleteEntry(top, n2i)
1068	            ac.pack(padx=6, pady=6)
1069	            def ok():
1070	                stat_id = ac.get_id()
1071	                if stat_id is None:
1072	                    messagebox.showwarning("Invalid", "Please select a stat")
1073	                    return
1074	                top.destroy()
1075	                if messagebox.askyesno("Confirm", f"Attach {item}({stat_id}) to team slot {idx}?"):
1076	                    # Build entry directly
1077	                    data = self.api.get_slot(slot)
1078	                    party = data.get("party") or []
1079	                    mon = party[idx-1]
1080	                    mon_id = mon.get("id")
1081	                    entry = {
1082	                        "args": [mon_id, stat_id],
1083	                        "player": True,
1084	                        "stackCount": 1,
1085	                        "typeId": "BASE_STAT_BOOSTER",
1086	                        "typePregenArgs": [stat_id],
1087	                    }
1088	                    mods = data.setdefault("modifiers", [])
1089	                    mods.append(entry)
1090	                    from rogueeditor.utils import slot_save_path, dump_json
1091	                    p = slot_save_path(self.api.username, slot)
1092	                    dump_json(p, data)
1093	                    self._log(f"Attached BASE_STAT_BOOSTER({stat_id}) to slot {idx}; wrote {p}")
1094	                    if messagebox.askyesno("Upload", "Upload changes to server?"):
1095	                        try:
1096	                            self.api.update_slot(slot, data)
1097	                            messagebox.showinfo("Uploaded", "Server updated.")
1098	                        except Exception as e:
1099	                            messagebox.showerror("Upload failed", str(e))
1100	            ttk.Button(top, text="OK", command=ok).pack(pady=6)
1101	            ac.focus_set()
1102	            self.wait_window(top)
1103	        else:
1104	            if messagebox.askyesno("Confirm", f"Attach {item} to team slot {idx}?"):
1105	                self.editor.add_item_to_mon(slot, idx, item)
1106	                self._log(f"Attached {item} to slot {idx}")
1107	
1108	    def _remove_item_dialog(self):
1109	        slot = self._ask_slot()
1110	        if not slot:
1111	            return
1112	        idx = self._ask_int("Team slot (1-5): ")
1113	        if not idx:
1114	            return
1115	        item = self._ask_str("Item type to remove: ")
1116	        if not item:
1117	            return
1118	        if messagebox.askyesno("Confirm", f"Remove {item} from team slot {idx}?"):
1119	            self.editor.remove_item_from_mon(slot, idx, item)
1120	            self._log(f"Removed {item} from slot {idx}")
1121	
1122	    # --- Simple inputs ---
1123	    def _ask_slot(self) -> int | None:
1124	        try:
1125	            return int(self._ask_str("Slot (1-5): ") or "0")
1126	        except ValueError:
1127	            messagebox.showwarning("Invalid", "Invalid slot")
1128	            return None
1129	
1130	    def _ask_int(self, prompt: str) -> int | None:
1131	        try:
1132	            return int(self._ask_str(prompt) or "0")
1133	        except ValueError:
1134	            messagebox.showwarning("Invalid", "Invalid number")
1135	            return None
1136	
1137	    def _ask_str(self, prompt: str) -> str:
1138	        top = tk.Toplevel(self)
1139	        top.title("Input")
1140	        ttk.Label(top, text=prompt).pack(padx=6, pady=6)
1141	        ent = ttk.Entry(top)
1142	        ent.pack(padx=6, pady=6)
1143	        out = {"v": None}
1144	        def ok():
1145	            out["v"] = ent.get().strip()
1146	            top.destroy()
1147	        ttk.Button(top, text="OK", command=ok).pack(pady=6)
1148	        ent.focus_set()
1149	        self.wait_window(top)
1150	        return out["v"]
1151	
1152	    # --- Starters handlers ---
1153	    def _get_starter_dex_id(self) -> int | None:
1154	        sid = self.starter_ac.get_id()
1155	        if sid is None:
1156	            messagebox.showwarning("Missing", "Select a Pokemon by name or id")
1157	            return None
1158	        return sid
1159	
1160	    def _apply_starter_attrs(self):
1161	        sid = self._get_starter_dex_id()
1162	        if sid is None:
1163	            return
1164	        # abilityAttr from checkboxes
1165	        mask = load_ability_attr_mask() or {"ability_1": 1, "ability_2": 2, "ability_hidden": 4}
1166	        ability_attr = (self.aa1.get() and mask.get("ability_1", 1) or 0) + \
1167	                       (self.aa2.get() and mask.get("ability_2", 2) or 0) + \
1168	                       (self.aah.get() and mask.get("ability_hidden", 4) or 0)
1169	        # passiveAttr from flags
1170	        passive_attr = (self.p_unlocked.get() and 1 or 0) + (self.p_enabled.get() and 2 or 0)
1171	        try:
1172	            value_reduction = int(self.starter_value_reduction.get().strip() or "0")
1173	        except ValueError:
1174	            messagebox.showwarning("Invalid", "valueReduction must be integer")
1175	            return
1176	        if not messagebox.askyesno("Confirm", f"Apply attrs to dex {sid} (save locally)?"):
1177	            return
1178	        data = self.api.get_trainer()
1179	        s = data.setdefault("starterData", {})
1180	        key = str(sid)
1181	        entry = s.get(key) or {"moveset": None, "eggMoves": 15, "candyCount": 0, "abilityAttr": 7, "passiveAttr": 0, "valueReduction": 0}
1182	        entry["abilityAttr"] = ability_attr
1183	        entry["passiveAttr"] = passive_attr
1184	        entry["valueReduction"] = value_reduction
1185	        s[key] = entry
1186	        # Save locally then offer upload
1187	        from rogueeditor.utils import trainer_save_path, dump_json
1188	        p = trainer_save_path(self.api.username)
1189	        dump_json(p, data)
1190	        messagebox.showinfo("Saved", f"Wrote {p}")
1191	        if messagebox.askyesno("Upload", "Upload trainer changes to server?"):
1192	            self.api.update_trainer(data)
1193	            messagebox.showinfo("Uploaded", "Server updated.")
1194	
1195	    def _inc_starter_candies(self):
1196	        sid = self._get_starter_dex_id()
1197	        if sid is None:
1198	            return
1199	        try:
1200	            delta = int(self.starter_candy_delta.get().strip() or "0")
1201	        except ValueError:
1202	            messagebox.showwarning("Invalid", "Delta must be integer")
1203	            return
1204	        if not messagebox.askyesno("Confirm", f"Increment candies by {delta} (save locally)?"):
1205	            return
1206	        data = self.api.get_trainer()
1207	        s = data.setdefault("starterData", {})
1208	        key = str(sid)
1209	        entry = s.get(key) or {"moveset": None, "eggMoves": 15, "candyCount": 0, "abilityAttr": 7, "passiveAttr": 0, "valueReduction": 0}
1210	        entry["candyCount"] = max(0, int(entry.get("candyCount", 0)) + delta)
1211	        s[key] = entry
1212	        from rogueeditor.utils import trainer_save_path, dump_json
1213	        p = trainer_save_path(self.api.username)
1214	        dump_json(p, data)
1215	        messagebox.showinfo("Saved", f"Wrote {p}")
1216	        if messagebox.askyesno("Upload", "Upload trainer changes to server?"):
1217	            self.api.update_trainer(data)
1218	            messagebox.showinfo("Uploaded", "Server updated.")
1219	
1220	    def _apply_gacha_delta(self):
1221	        try:
1222	            d0 = int(self.gacha_d0.get().strip() or "0")
1223	            d1 = int(self.gacha_d1.get().strip() or "0")
1224	            d2 = int(self.gacha_d2.get().strip() or "0")
1225	            d3 = int(self.gacha_d3.get().strip() or "0")
1226	        except ValueError:
1227	            messagebox.showwarning("Invalid", "All deltas must be integers")
1228	            return
1229	        if not messagebox.askyesno("Confirm", f"Apply gacha deltas C/R/E/L = {d0}/{d1}/{d2}/{d3} (save locally)?"):
1230	            return
1231	        data = self.api.get_trainer()
1232	        current = data.get("voucherCounts") or {}
1233	        def cur(k):
1234	            try:
1235	                return int(current.get(k, 0))
1236	            except Exception:
1237	                return 0
1238	        updated = {
1239	            "0": max(0, cur("0") + d0),
1240	            "1": max(0, cur("1") + d1),
1241	            "2": max(0, cur("2") + d2),
1242	            "3": max(0, cur("3") + d3),
1243	        }
1244	        data["voucherCounts"] = updated
1245	        from rogueeditor.utils import trainer_save_path, dump_json
1246	        p = trainer_save_path(self.api.username)
1247	        dump_json(p, data)
1248	        messagebox.showinfo("Saved", f"Wrote {p}")
1249	        if messagebox.askyesno("Upload", "Upload trainer changes to server?"):
1250	            self.api.update_trainer(data)
1251	            messagebox.showinfo("Uploaded", "Gacha tickets updated on server")
1252	
1253	
1254	def run():
1255	    app = App()
1256	    app.mainloop()
1257	
1258	
1259	class AutoCompleteEntry(ttk.Entry):
1260	    def __init__(self, master, name_to_id: dict[str, int], **kwargs):
1261	        super().__init__(master, **kwargs)
1262	        self._name_to_id = name_to_id
1263	        self._popup = None
1264	        self._var = tk.StringVar()
1265	        self.config(textvariable=self._var)
1266	        self._var.trace_add('write', self._on_change)
1267	        self.bind('<Down>', self._move_down)
1268	        self._selected_id = None
1269	
1270	    def get_id(self):
1271	        v = self._var.get().strip()
1272	        if v.isdigit():
1273	            return int(v)
1274	        key = v.lower().replace(' ', '_')
1275	        if key in self._name_to_id:
1276	            return self._name_to_id[key]
1277	        return self._selected_id
1278	
1279	    def set_value(self, text: str):
1280	        self._var.set(text)
1281	
1282	    def _on_change(self, *args):
1283	        text = self._var.get().strip().lower().replace(' ', '_')
1284	        if not text:
1285	            self._hide_popup()
1286	            return
1287	        matches = [n for n in self._name_to_id.keys() if text in n][:10]
1288	        if not matches:
1289	            self._hide_popup()
1290	            return
1291	        if not self._popup:
1292	            self._popup = tk.Toplevel(self)
1293	            self._popup.wm_overrideredirect(True)
1294	            self._list = tk.Listbox(self._popup)
1295	            self._list.pack()
1296	            self._list.bind('<Double-Button-1>', self._select)
1297	            self._list.bind('<Return>', self._select)
1298	        self._list.delete(0, tk.END)
1299	        for m in matches:
1300	            disp = f"{m} ({self._name_to_id.get(m)})"
1301	            self._list.insert(tk.END, disp)
1302	        x = self.winfo_rootx()
1303	        y = self.winfo_rooty() + self.winfo_height()
1304	        self._popup.geometry(f"300x180+{x}+{y}")
1305	        self._popup.deiconify()
1306	
1307	    def _move_down(self, event):
1308	        if self._popup:
1309	            self._list.focus_set()
1310	            if self._list.size() > 0:
1311	                self._list.selection_set(0)
1312	        return 'break'
1313	
1314	    def _select(self, event=None):
1315	        if not self._popup:
1316	            return
1317	        try:
1318	            sel = self._list.get(self._list.curselection())
1319	        except Exception:
1320	            return
1321	        # sel could be 'name (id)'; extract name
1322	        name = sel.split(' (', 1)[0]
1323	        self._var.set(name)
1324	        self._selected_id = self._name_to_id.get(name)
1325	        self._hide_popup()
1326	
1327	    def _hide_popup(self):
1328	        if self._popup:
1329	            self._popup.destroy()
1330	            self._popup = None
1331	
1332	
1333	class TeamEditorDialog(tk.Toplevel):
1334	    def __init__(self, master: App, api: PokerogueAPI, editor: Editor, slot: int):
1335	        super().__init__(master)
1336	        self.title(f"Team Editor - Slot {slot}")
1337	        self.geometry("900x500")
1338	        self.api = api
1339	        self.editor = editor
1340	        self.slot = slot
1341	        self.data = self.api.get_slot(slot)
1342	        self.party = self.data.get("party") or []
1343	        self._build()
1344	
1345	    def _build(self):
1346	        frame = ttk.Frame(self)
1347	        frame.pack(fill=tk.BOTH, expand=True)
1348	        # Left: team list
1349	        left = ttk.Frame(frame)
1350	        left.pack(side=tk.LEFT, fill=tk.Y, padx=6, pady=6)
1351	        self.team_list = tk.Listbox(left, height=10, exportselection=False)
1352	        self.team_list.pack(fill=tk.Y)
1353	        self.team_list.bind('<<ListboxSelect>>', self._on_select)
1354	        # Populate
1355	        from rogueeditor.utils import load_pokemon_index, invert_dex_map
1356	        inv = invert_dex_map(load_pokemon_index())
1357	        for i, mon in enumerate(self.party, start=1):
1358	            did = str(mon.get("species") or mon.get("dexId") or mon.get("speciesId") or "?")
1359	            name = inv.get(did, did)
1360	            lvl = mon.get("level") or mon.get("lvl")
1361	            self.team_list.insert(tk.END, f"{i}. {name} (Lv {lvl})")
1362	        # Right: editor
1363	        right = ttk.Frame(frame)
1364	        right.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=6, pady=6)
1365	        self._build_editor(right)
1366	
1367	    def _build_editor(self, parent):
1368	        move_name_to_id, move_id_to_name = load_move_catalog()
1369	        abil_name_to_id, abil_id_to_name = load_ability_catalog()
1370	        nat_name_to_id, nat_id_to_name = load_nature_catalog()
1371	        # Store move catalogs for labels
1372	        self.move_name_to_id = move_name_to_id
1373	        self.move_id_to_name = move_id_to_name
1374	
1375	        ttk.Label(parent, text="Level:").grid(row=0, column=0, sticky=tk.W)
1376	        self.level_var = tk.StringVar()
1377	        ttk.Entry(parent, textvariable=self.level_var, width=6).grid(row=0, column=1, sticky=tk.W)
1378	        # Recalculate stats when level changes
1379	        def _on_level_change(*args):
1380	            try:
1381	                _ = int(self.level_var.get().strip() or '0')
1382	            except Exception:
1383	                pass
1384	            self._update_calculated_stats()
1385	        try:
1386	            self.level_var.trace_remove('write', getattr(self.level_var, '_lvl_trace', None))
1387	        except Exception:
1388	            pass
1389	        self.level_var._lvl_trace = self.level_var.trace_add('write', _on_level_change)
1390	
1391	        ttk.Label(parent, text="Ability:").grid(row=1, column=0, sticky=tk.W)
1392	        self.ability_ac = AutoCompleteEntry(parent, abil_name_to_id)
1393	        self.ability_ac.grid(row=1, column=1, sticky=tk.W)
1394	        ttk.Button(parent, text="Pick", command=lambda: self._pick_from_catalog(self.ability_ac, abil_name_to_id, 'Select Ability')).grid(row=1, column=2, sticky=tk.W)
1395	
1396	        ttk.Label(parent, text="Nature:").grid(row=2, column=0, sticky=tk.W)
1397	        # Nature combobox with effect hints (e.g., Adamant +Atk/-SpA)
1398	        from rogueeditor.catalog import nature_multipliers_by_id
1399	        mults_map = nature_multipliers_by_id()
1400	        def _pretty(s: str) -> str:
1401	            return s.replace('_', ' ').title()
1402	        def _effect_text(nid: int) -> str:
1403	            arr = mults_map.get(int(nid), [1.0]*6)
1404	            labs = ["HP","Atk","Def","SpA","SpD","Spe"]
1405	            up = next((labs[i] for i,v in enumerate(arr) if i>0 and abs(v-1.1)<1e-6), None)
1406	            dn = next((labs[i] for i,v in enumerate(arr) if i>0 and abs(v-0.9)<1e-6), None)
1407	            if not up or not dn or up == dn:
1408	                return "neutral"
1409	            return f"+{up}/-{dn}"
1410	        nature_items = []
1411	        # Use id->name to preserve source names; prettify for display
1412	        for nid, raw_name in sorted(load_nature_catalog()[1].items(), key=lambda kv: kv[0]):
1413	            effect = _effect_text(nid)
1414	            disp = f"{_pretty(raw_name)} ({effect}) ({nid})"
1415	            nature_items.append(disp)
1416	        self.nature_cb = ttk.Combobox(parent, values=nature_items, width=28)
1417	        self.nature_cb.grid(row=2, column=1, sticky=tk.W)
1418	        self.nature_cb.bind('<<ComboboxSelected>>', lambda e: self._on_nature_change())
1419	        # Nature effect hint label
1420	        self.nature_hint = ttk.Label(parent, text="")
1421	        self.nature_hint.grid(row=2, column=5, sticky=tk.W)
1422	
1423	        # Held Item
1424	        ttk.Label(parent, text="Held Item:").grid(row=2, column=2, sticky=tk.W)
1425	        try:
1426	            item_name_to_id, item_id_to_name = load_item_catalog()
1427	        except Exception:
1428	            item_name_to_id = {}
1429	            item_id_to_name = {}
1430	        if item_name_to_id:
1431	            self.held_item_ac = AutoCompleteEntry(parent, item_name_to_id, width=20)
1432	            self.held_item_ac.grid(row=2, column=3, sticky=tk.W)
1433	            ttk.Button(parent, text="Pick", command=lambda: self._pick_from_catalog(self.held_item_ac, item_name_to_id, 'Select Item')).grid(row=2, column=4, sticky=tk.W)
1434	            self.held_item_var = None
1435	        else:
1436	            self.held_item_var = tk.StringVar()
1437	            ttk.Entry(parent, textvariable=self.held_item_var, width=8).grid(row=2, column=3, sticky=tk.W)
1438	
1439	        # IVs in two columns of three
1440	        ttk.Label(parent, text="IVs:").grid(row=3, column=0, sticky=tk.NW)
1441	        self.iv_vars = [tk.StringVar() for _ in range(6)]
1442	        iv_labels = ["HP", "Atk", "Def", "SpA", "SpD", "Spe"]
1443	        iv_frame = ttk.Frame(parent)
1444	        iv_frame.grid(row=3, column=1, columnspan=3, sticky=tk.W)
1445	        # Left column (HP/Atk/Def)
1446	        for i, lab in enumerate(iv_labels[:3]):
1447	            ttk.Label(iv_frame, text=lab+":").grid(row=i, column=0, sticky=tk.E, padx=2, pady=1)
1448	            ttk.Entry(iv_frame, textvariable=self.iv_vars[i], width=4).grid(row=i, column=1, sticky=tk.W)
1449	        # Right column (SpA/SpD/Spe)
1450	        for j, lab in enumerate(iv_labels[3:], start=3):
1451	            ttk.Label(iv_frame, text=lab+":").grid(row=j-3, column=2, sticky=tk.E, padx=8, pady=1)
1452	            ttk.Entry(iv_frame, textvariable=self.iv_vars[j], width=4).grid(row=j-3, column=3, sticky=tk.W)
1453	
1454	        # Calculated Stats (derived from Level + IVs, EV=0)
1455	        ttk.Label(parent, text="Calculated Stats:").grid(row=4, column=0, sticky=tk.NW)
1456	        stats_frame = ttk.Frame(parent)
1457	        stats_frame.grid(row=4, column=1, columnspan=3, sticky=tk.W)
1458	        self.stat_lbls = []
1459	        for i, lab in enumerate(["HP", "Atk", "Def", "SpA", "SpD", "Spe"]):
1460	            ttk.Label(stats_frame, text=lab+":").grid(row=i//3, column=(i%3)*2, sticky=tk.W, padx=(0, 4))
1461	            val = ttk.Label(stats_frame, text="-")
1462	            val.grid(row=i//3, column=(i%3)*2+1, sticky=tk.W, padx=(0, 12))
1463	            self.stat_lbls.append(val)
1464	
1465	        ttk.Label(parent, text="Moves:").grid(row=5, column=0, sticky=tk.W)
1466	        self.move_acs = []
1467	        self.move_lbls = []
1468	        for i in range(4):
1469	            ac = AutoCompleteEntry(parent, move_name_to_id, width=30)
1470	            ac.grid(row=5+i, column=1, sticky=tk.W, pady=1)
1471	            ac.bind('<KeyRelease>', lambda e, j=i: self._on_move_ac_change(j))
1472	            ac.bind('<FocusOut>', lambda e, j=i: self._on_move_ac_change(j))
1473	            ttk.Button(parent, text="Pick", command=lambda j=i: self._pick_from_catalog(self.move_acs[j], move_name_to_id, f'Select Move {j+1}')).grid(row=5+i, column=2, sticky=tk.W)
1474	            lbl = ttk.Label(parent, text="", width=28)
1475	            lbl.grid(row=5+i, column=3, sticky=tk.W, padx=6)
1476	            self.move_lbls.append(lbl)
1477	            self.move_acs.append(ac)
1478	
1479	        ttk.Button(parent, text="Save to file", command=self._save).grid(row=10, column=0, pady=8)
1480	        ttk.Button(parent, text="Upload", command=self._upload).grid(row=10, column=1, pady=8)
1481	
1482	    def _on_select(self, event=None):
1483	        if not self.team_list.curselection():
1484	            return
1485	        idx = self.team_list.curselection()[0]
1486	        mon = self.party[idx]
1487	        # Populate fields
1488	        lvl = mon.get("level") or mon.get("lvl") or ""
1489	        self.level_var.set(str(lvl))
1490	        # Ability
1491	        abil = mon.get("abilityId") or mon.get("ability") or ""
1492	        self.ability_ac.set_value(str(abil))
1493	        # Nature (handled via combobox below)
1494	        nat = mon.get("natureId") or mon.get("nature") or ""
1495	        try:
1496	            nid = int(nat)
1497	            from rogueeditor.catalog import load_nature_catalog, nature_multipliers_by_id
1498	            n2i, i2n = load_nature_catalog()
1499	            name = i2n.get(nid, str(nid))
1500	            # include effect in display
1501	            arr = nature_multipliers_by_id().get(int(nid), [1.0]*6)
1502	            labs = ["HP","Atk","Def","SpA","SpD","Spe"]
1503	            up = next((labs[i] for i,v in enumerate(arr) if i>0 and abs(v-1.1)<1e-6), None)
1504	            dn = next((labs[i] for i,v in enumerate(arr) if i>0 and abs(v-0.9)<1e-6), None)
1505	            effect = "neutral" if (not up or not dn or up==dn) else f"+{up}/-{dn}"
1506	            self.nature_cb.set(f"{name.replace('_',' ').title()} ({effect}) ({nid})")
1507	            self._update_nature_hint(arr)
1508	        except Exception:
1509	            self.nature_cb.set(str(nat))
1510	            self._update_nature_hint([1.0]*6)
1511	        # Moves
1512	        moves = []
1513	        mv = mon.get("moveset") or mon.get("moveIds") or mon.get("moves") or []
1514	        for i in range(4):
1515	            cur = mv[i] if i < len(mv) else None
1516	            if isinstance(cur, dict):
1517	                val = cur.get("id") or cur.get("moveId") or ""
1518	            else:
1519	                val = cur or ""
1520	            self.move_acs[i].set_value(str(val))
1521	            self._update_move_label(i)
1522	        # Held item id
1523	        hid = mon.get("heldItemId") or mon.get("heldItem") or mon.get("item") or ""
1524	        if hasattr(self, 'held_item_ac') and self.held_item_ac:
1525	            self.held_item_ac.set_value(str(hid))
1526	        else:
1527	            self.held_item_var.set(str(hid))
1528	        # IVs
1529	        ivs = mon.get("ivs")
1530	        if isinstance(ivs, list) and len(ivs) == 6:
1531	            for i in range(6):
1532	                self.iv_vars[i].set(str(ivs[i]))
1533	        else:
1534	            for i in range(6):
1535	                self.iv_vars[i].set("")
1536	        # Attach IV change listeners and initialize base + calculated stats
1537	        for v in self.iv_vars:
1538	            try:
1539	                v.trace_remove('write', getattr(v, '_calc_trace', None))
1540	            except Exception:
1541	                pass
1542	            def _cb(*args, sv=v):
1543	                self._update_calculated_stats()
1544	            v._calc_trace = v.trace_add('write', _cb)
1545	        self._init_base_and_update()
1546	        # Also refresh hint/labels based on current nature
1547	        try:
1548	            from rogueeditor.catalog import nature_multipliers_by_id
1549	            nid = self._get_nature_id()
1550	            arr = nature_multipliers_by_id().get(nid or -1, [1.0]*6)
1551	        except Exception:
1552	            arr = [1.0]*6
1553	        self._update_nature_hint(arr)
1554	
1555	    def _apply_form_changes(self) -> bool:
1556	        # Applies UI fields to current mon in self.data; returns True if applied
1557	        if not self.team_list.curselection():
1558	            return False
1559	        idx = self.team_list.curselection()[0]
1560	        mon = self.party[idx]
1561	        # Level
1562	        lv = self.level_var.get().strip()
1563	        if lv.isdigit():
1564	            if "level" in mon:
1565	                mon["level"] = int(lv)
1566	            elif "lvl" in mon:
1567	                mon["lvl"] = int(lv)
1568	        # Ability
1569	        aid = self.ability_ac.get_id()
1570	        if aid is not None:
1571	            if "abilityId" in mon:
1572	                mon["abilityId"] = aid
1573	            elif "ability" in mon:
1574	                mon["ability"] = aid
1575	        # Nature
1576	        ndisp = self.nature_cb.get().strip()
1577	        nid = None
1578	        if ndisp.endswith(')') and '(' in ndisp:
1579	            try:
1580	                nid = int(ndisp.rsplit('(',1)[1].rstrip(')'))
1581	            except Exception:
1582	                nid = None
1583	        if nid is not None:
1584	            if "natureId" in mon:
1585	                mon["natureId"] = nid
1586	            elif "nature" in mon:
1587	                mon["nature"] = nid
1588	        # IVs
1589	        new_ivs = []
1590	        valid_iv = True
1591	        for v in self.iv_vars:
1592	            s = v.get().strip()
1593	            if not s:
1594	                valid_iv = False
1595	                break
1596	            try:
1597	                val = int(s)
1598	                if val < 0:
1599	                    val = 0
1600	                if val > 31:
1601	                    val = 31
1602	                new_ivs.append(val)
1603	            except ValueError:
1604	                valid_iv = False
1605	                break
1606	        if valid_iv and len(new_ivs) == 6:
1607	            mon["ivs"] = new_ivs
1608	            # Update mon stat fields if present
1609	            try:
1610	                base = getattr(self, '_base_stats', None)
1611	                if base and len(base) == 6:
1612	                    lvl = self._get_level()
1613	                    calc = self._compute_stats(base, lvl, new_ivs)
1614	                    key_pairs = [("maxHp", "hp"), ("attack", "atk"), ("defense", "def"), ("spAttack", "spAtk"), ("spDefense", "spDef"), ("speed", "spd")]
1615	                    for i, (k1, k2) in enumerate(key_pairs):
1616	                        for k in (k1, k2):
1617	                            if k in mon:
1618	                                mon[k] = calc[i]
1619	            except Exception:
1620	                pass
1621	        # Moves
1622	        moves = []
1623	        for ac in self.move_acs:
1624	            mid = ac.get_id()
1625	            if mid is not None:
1626	                moves.append({"moveId": mid, "ppUp": 0, "ppUsed": 0})
1627	        if moves:
1628	            if "moveset" in mon:
1629	                mon["moveset"] = moves
1630	            elif "moveIds" in mon:
1631	                mon["moveIds"] = [m["moveId"] for m in moves]
1632	            elif "moves" in mon:
1633	                mon["moves"] = [m["moveId"] for m in moves]
1634	        # Held item
1635	        if hasattr(self, 'held_item_ac') and self.held_item_ac:
1636	            iid = self.held_item_ac.get_id()
1637	            if iid is not None:
1638	                if "heldItemId" in mon:
1639	                    mon["heldItemId"] = iid
1640	                elif "heldItem" in mon:
1641	                    mon["heldItem"] = iid
1642	                elif "item" in mon:
1643	                    mon["item"] = iid
1644	        else:
1645	            hv = self.held_item_var.get().strip()
1646	            if hv.isdigit():
1647	                hid = int(hv)
1648	                if "heldItemId" in mon:
1649	                    mon["heldItemId"] = hid
1650	                elif "heldItem" in mon:
1651	                    mon["heldItem"] = hid
1652	                elif "item" in mon:
1653	                    mon["item"] = hid
1654	        return True
1655	
1656	    def _save(self):
1657	        from rogueeditor.utils import slot_save_path, dump_json
1658	        if not self._apply_form_changes():
1659	            messagebox.showwarning("No selection", "Select a team member first")
1660	            return
1661	        save_path = slot_save_path(self.api.username, self.slot)
1662	        dump_json(save_path, self.data)
1663	        messagebox.showinfo("Saved", f"Wrote {save_path}")
1664	
1665	    def _upload(self):
1666	        if not messagebox.askyesno("Confirm Upload", "This will overwrite server slot data. Proceed?"):
1667	            return
1668	        try:
1669	            # Apply UI changes, write to file, then upload that file
1670	            from rogueeditor.utils import slot_save_path, dump_json, load_json
1671	            p = slot_save_path(self.api.username, self.slot)
1672	            self._apply_form_changes()
1673	            dump_json(p, self.data)
1674	            # Then read back and upload exactly that file
1675	            payload = load_json(p)
1676	            self.api.update_slot(self.slot, payload)
1677	            messagebox.showinfo("Uploaded", "Server updated successfully")
1678	        except Exception as e:
1679	            messagebox.showerror("Upload failed", str(e))
1680	
1681	    # --- IV/stat helpers ---
1682	    def _get_level(self) -> int:
1683	        try:
1684	            return int(self.level_var.get().strip())
1685	        except Exception:
1686	            try:
1687	                sel = self.team_list.curselection()[0]
1688	                mon = self.party[sel]
1689	                return int(mon.get('level') or mon.get('lvl') or 1)
1690	            except Exception:
1691	                return 1
1692	
1693	    def _parse_ivs(self) -> list[int] | None:
1694	        vals: list[int] = []
1695	        for v in self.iv_vars:
1696	            s = v.get().strip()
1697	            if not s or not s.isdigit():
1698	                return None
1699	            try:
1700	                iv = int(s)
1701	                if iv < 0:
1702	                    iv = 0
1703	                if iv > 31:
1704	                    iv = 31
1705	                vals.append(iv)
1706	            except ValueError:
1707	                return None
1708	        return vals if len(vals) == 6 else None
1709	
1710	    def _extract_actual_stats(self, mon: dict) -> list[int] | None:
1711	        pairs = [("maxHp", "hp"), ("attack", "atk"), ("defense", "def"), ("spAttack", "spAtk"), ("spDefense", "spDef"), ("speed", "spd")]
1712	        out: list[int] = []
1713	        for k1, k2 in pairs:
1714	            val = mon.get(k1)
1715	            if val is None:
1716	                val = mon.get(k2)
1717	            if val is None:
1718	                return None
1719	            try:
1720	                out.append(int(val))
1721	            except Exception:
1722	                return None
1723	        return out
1724	
1725	    def _infer_base_stats(self, level: int, ivs: list[int], actual: list[int]) -> list[int]:
1726	        def ev_effective(E: int) -> int:
1727	            return math.floor(math.ceil(math.sqrt(E)) / 4)
1728	        # Nature multipliers for current mon
1729	        try:
1730	            from rogueeditor.catalog import nature_multipliers_by_id
1731	            nid = self._get_nature_id()
1732	            mults = nature_multipliers_by_id().get(nid or -1, [1.0] * 6)
1733	        except Exception:
1734	            mults = [1.0] * 6
1735	        base: list[int] = []
1736	        # HP (no nature)
1737	        hp = actual[0]
1738	        hp_inner = ((hp - level - 10) * 100) / max(1, level)
1739	        two_b_plus_two_i = max(0, math.ceil(hp_inner) - ev_effective(0))
1740	        base.append(max(1, round((two_b_plus_two_i - 2 * ivs[0]) / 2)))
1741	        # Other stats: reverse nature first
1742	        for i in range(1, 6):
1743	            stat = actual[i]
1744	            m = mults[i] if i < len(mults) else 1.0
1745	            if m and m != 1.0:
1746	                stat = round(stat / m)
1747	            inner = ((stat - 5) * 100) / max(1, level)
1748	            two_b_plus_two_i = max(0, math.ceil(inner) - ev_effective(0))
1749	            base.append(max(1, round((two_b_plus_two_i - 2 * ivs[i]) / 2)))
1750	        return base
1751	
1752	    def _compute_stats(self, base: list[int], level: int, ivs: list[int]) -> list[int]:
1753	        def ev_effective(E: int) -> int:
1754	            return math.floor(math.ceil(math.sqrt(E)) / 4)
1755	        try:
1756	            from rogueeditor.catalog import nature_multipliers_by_id
1757	            nid = self._get_nature_id()
1758	            mults = nature_multipliers_by_id().get(nid or -1, [1.0] * 6)
1759	        except Exception:
1760	            mults = [1.0] * 6
1761	        hp = math.floor((((2 * (base[0] + ivs[0])) + ev_effective(0)) * level) / 100) + level + 10
1762	        out = [hp]
1763	        for i in range(1, 6):
1764	            val = math.floor((((2 * (base[i] + ivs[i])) + ev_effective(0)) * level) / 100) + 5
1765	            m = mults[i] if i < len(mults) else 1.0
1766	            val = math.floor(val * m + 1e-6)
1767	            out.append(val)
1768	        return out
1769	
1770	    def _init_base_and_update(self):
1771	        try:
1772	            sel = self.team_list.curselection()[0]
1773	            mon = self.party[sel]
1774	        except Exception:
1775	            return
1776	        ivs = self._parse_ivs()
1777	        if not ivs:
1778	            return
1779	        lvl = self._get_level()
1780	        actual = self._extract_actual_stats(mon)
1781	        if actual:
1782	            self._base_stats = self._infer_base_stats(lvl, ivs, actual)
1783	        else:
1784	            self._base_stats = [50, 50, 50, 50, 50, 50]
1785	        self._update_calculated_stats()
1786	
1787	    def _update_calculated_stats(self):
1788	        ivs = self._parse_ivs()
1789	        base = getattr(self, '_base_stats', None)
1790	        if not ivs or not base or len(base) != 6:
1791	            for lbl in getattr(self, 'stat_lbls', []):
1792	                lbl.configure(text='-')
1793	            return
1794	        lvl = self._get_level()
1795	        vals = self._compute_stats(base, lvl, ivs)
1796	        # Show +/- markers for nature effects on non-HP stats
1797	        try:
1798	            from rogueeditor.catalog import nature_multipliers_by_id
1799	            arr = nature_multipliers_by_id().get(self._get_nature_id() or -1, [1.0]*6)
1800	        except Exception:
1801	            arr = [1.0]*6
1802	        for i, lbl in enumerate(self.stat_lbls):
1803	            suffix = ""
1804	            if i > 0:
1805	                if abs(arr[i]-1.1) < 1e-6:
1806	                    suffix = " (+)"
1807	                elif abs(arr[i]-0.9) < 1e-6:
1808	                    suffix = " (-)"
1809	            lbl.configure(text=f"{vals[i]}{suffix}")
1810	
1811	    def _on_nature_change(self):
1812	        # Recalc displays when nature changes
1813	        self._update_calculated_stats()
1814	        try:
1815	            from rogueeditor.catalog import nature_multipliers_by_id
1816	            arr = nature_multipliers_by_id().get(self._get_nature_id() or -1, [1.0]*6)
1817	        except Exception:
1818	            arr = [1.0]*6
1819	        self._update_nature_hint(arr)
1820	
1821	    def _update_nature_hint(self, arr: list[float]):
1822	        labs = ["HP","Atk","Def","SpA","SpD","Spe"]
1823	        up = next((labs[i] for i,v in enumerate(arr) if i>0 and abs(v-1.1)<1e-6), None)
1824	        dn = next((labs[i] for i,v in enumerate(arr) if i>0 and abs(v-0.9)<1e-6), None)
1825	        if not up or not dn or up == dn:
1826	            self.nature_hint.configure(text="neutral")
1827	        else:
1828	            self.nature_hint.configure(text=f"+{up} / -{dn}")
1829	    def _get_nature_id(self) -> int | None:
1830	        raw = self.nature_cb.get().strip()
1831	        if not raw:
1832	            return None
1833	        if raw.endswith(')') and '(' in raw:
1834	            try:
1835	                return int(raw.rsplit('(', 1)[1].rstrip(')'))
1836	            except Exception:
1837	                pass
1838	        try:
1839	            from rogueeditor.catalog import load_nature_catalog
1840	            name_to_id, _ = load_nature_catalog()
1841	            key = raw.strip().lower().replace(' ', '_')
1842	            return int(name_to_id.get(key)) if key in name_to_id else None
1843	        except Exception:
1844	            return None
1845	    def _on_move_ac_change(self, idx: int):
1846	        self._update_move_label(idx)
1847	
1848	    def _update_move_label(self, idx: int):
1849	        if 0 <= idx < len(self.move_acs):
1850	            ac = self.move_acs[idx]
1851	            text = ac.get().strip()
1852	            mid = None
1853	            if text.isdigit():
1854	                mid = int(text)
1855	            else:
1856	                if text.endswith(')') and '(' in text:
1857	                    try:
1858	                        mid = int(text.rsplit('(',1)[1].rstrip(')'))
1859	                    except Exception:
1860	                        mid = None
1861	                if mid is None:
1862	                    key = text.lower().replace(' ', '_')
1863	                    mid = self.move_name_to_id.get(key)
1864	            label = ''
1865	            if isinstance(mid, int):
1866	                name = self.move_id_to_name.get(mid, str(mid))
1867	                label = f"{name} (#{mid})"
1868	            self.move_lbls[idx].configure(text=label)
1869	
1870	    def _pick_from_catalog(self, ac: AutoCompleteEntry, name_to_id: dict[str, int], title: str):
1871	        sel = CatalogSelectDialog.select(self, name_to_id, title)
1872	        if sel is not None:
1873	            # find name by id
1874	            name = None
1875	            for k, v in name_to_id.items():
1876	                if v == sel:
1877	                    name = k
1878	                    break
1879	            ac.set_value(name or str(sel))
1880	
1881	
1882	class ModifiersManagerDialog(tk.Toplevel):
1883	    def __init__(self, master: App, api: PokerogueAPI, editor: Editor, slot: int):
1884	        super().__init__(master)
1885	        self.title(f"Modifiers Manager - Slot {slot}")
1886	        self.geometry("900x500")
1887	        self.api = api
1888	        self.editor = editor
1889	        self.slot = slot
1890	        self._build()
1891	        self._refresh()
1892	
1893	    def _build(self):
1894	        top = ttk.Frame(self)
1895	        top.pack(fill=tk.BOTH, expand=True, padx=6, pady=6)
1896	        # Player modifiers
1897	        left = ttk.LabelFrame(top, text="Player Modifiers")
1898	        left.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=4, pady=4)
1899	        cols = ("idx", "typeId", "className", "args", "stack")
1900	        self.player_tree = ttk.Treeview(left, columns=cols, show="headings", height=10)
1901	        for c, w in (("idx", 50), ("typeId", 150), ("className", 200), ("args", 200), ("stack", 60)):
1902	            self.player_tree.heading(c, text=c)
1903	            self.player_tree.column(c, width=w, anchor=tk.W)
1904	        self.player_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
1905	        sb1 = ttk.Scrollbar(left, orient="vertical", command=self.player_tree.yview)
1906	        self.player_tree.configure(yscrollcommand=sb1.set)
1907	        sb1.pack(side=tk.RIGHT, fill=tk.Y)
1908	        btns1 = ttk.Frame(left)
1909	        btns1.pack(fill=tk.X)
1910	        ttk.Button(btns1, text="Add Player Modifier", command=self._add_player_mod).pack(side=tk.LEFT, padx=4, pady=4)
1911	        ttk.Button(btns1, text="Remove Selected", command=self._remove_player_mod).pack(side=tk.LEFT, padx=4, pady=4)
1912	
1913	        # Pokemon modifiers
1914	        right = ttk.LabelFrame(top, text="Pokemon Modifiers")
1915	        right.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=4, pady=4)
1916	        cols2 = ("idx", "typeId", "className", "args", "target")
1917	        self.pokemon_tree = ttk.Treeview(right, columns=cols2, show="headings", height=10)
1918	        for c, w in (("idx", 50), ("typeId", 150), ("className", 200), ("args", 200), ("target", 120)):
1919	            self.pokemon_tree.heading(c, text=c)
1920	            self.pokemon_tree.column(c, width=w, anchor=tk.W)
1921	        self.pokemon_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
1922	        sb2 = ttk.Scrollbar(right, orient="vertical", command=self.pokemon_tree.yview)
1923	        self.pokemon_tree.configure(yscrollcommand=sb2.set)
1924	        sb2.pack(side=tk.RIGHT, fill=tk.Y)
1925	        btns2 = ttk.Frame(right)
1926	        btns2.pack(fill=tk.X)
1927	        ttk.Button(btns2, text="Remove Selected", command=self._remove_pokemon_mod).pack(side=tk.LEFT, padx=4, pady=4)
1928	        ttk.Button(btns2, text="Refresh", command=self._refresh).pack(side=tk.LEFT, padx=4, pady=4)
1929	
1930	        # Upload/save
1931	        bottom = ttk.Frame(self)
1932	        bottom.pack(fill=tk.X, padx=6, pady=6)
1933	        ttk.Button(bottom, text="Upload Changes", command=self._upload).pack(side=tk.LEFT)
1934	
1935	    def _refresh(self):
1936	        # Populate trees
1937	        det = self.editor.list_modifiers_detailed(self.slot)
1938	        player_mods, by_mon = self.editor.group_modifiers(self.slot)
1939	        for t in (self.player_tree, self.pokemon_tree):
1940	            for r in t.get_children():
1941	                t.delete(r)
1942	        # Player
1943	        for idx, m in player_mods:
1944	            self.player_tree.insert('', 'end', values=(idx, m.get('typeId'), m.get('className'), m.get('args'), m.get('stackCount')))
1945	        # Pokemon
1946	        # Map mon id -> display label
1947	        party = (self.api.get_slot(self.slot).get('party') or [])
1948	        party_map = {p.get('id'): p for p in party if isinstance(p, dict) and 'id' in p}
1949	        from rogueeditor.utils import invert_dex_map, load_pokemon_index
1950	        inv = invert_dex_map(load_pokemon_index())
1951	        for mon_id, mods in by_mon.items():
1952	            label = 'unknown'
1953	            mon = party_map.get(mon_id)
1954	            if mon:
1955	                did = str(mon.get('species') or mon.get('dexId') or mon.get('speciesId') or '?')
1956	                name = inv.get(did, did)
1957	                label = f"{name} (id {mon_id})"
1958	            for idx, m in mods:
1959	                self.pokemon_tree.insert('', 'end', values=(idx, m.get('typeId'), m.get('className'), m.get('args'), label))
1960	
1961	    def _add_player_mod(self):
1962	        top = tk.Toplevel(self)
1963	        top.title("Add Player Modifier")
1964	        ttk.Label(top, text="TypeId:").grid(row=0, column=0, padx=4, pady=4)
1965	        type_var = tk.StringVar()
1966	        ttk.Entry(top, textvariable=type_var, width=30).grid(row=0, column=1, padx=4, pady=4)
1967	        ttk.Label(top, text="Args (comma ints, optional):").grid(row=1, column=0, padx=4, pady=4)
1968	        args_var = tk.StringVar()
1969	        ttk.Entry(top, textvariable=args_var, width=30).grid(row=1, column=1, padx=4, pady=4)
1970	        ttk.Label(top, text="Stack count:").grid(row=2, column=0, padx=4, pady=4)
1971	        stack_var = tk.StringVar(value='1')
1972	        ttk.Entry(top, textvariable=stack_var, width=6).grid(row=2, column=1, padx=4, pady=4, sticky=tk.W)
1973	        def ok():
1974	            tid = type_var.get().strip()
1975	            if not tid:
1976	                return
1977	            args_text = args_var.get().strip()
1978	            args = None
1979	            if args_text:
1980	                try:
1981	                    args = [int(x.strip()) for x in args_text.split(',') if x.strip()]
1982	                except Exception:
1983	                    messagebox.showwarning('Invalid', 'Args must be comma-separated integers')
1984	                    return
1985	            try:
1986	                stack = int(stack_var.get().strip() or '1')
1987	            except ValueError:
1988	                stack = 1
1989	            self.editor.add_player_modifier(self.slot, tid, args, stack)
1990	            self._refresh()
1991	            top.destroy()
1992	        ttk.Button(top, text='Add', command=ok).grid(row=3, column=1, padx=4, pady=6, sticky=tk.W)
1993	
1994	    def _remove_player_mod(self):
1995	        sel = self.player_tree.selection()
1996	        if not sel:
1997	            return
1998	        item = self.player_tree.item(sel[0])
1999	        idx = item.get('values')[0]
2000	        try:
2001	            idx = int(idx)
2002	        except Exception:
2003	            return
2004	        if messagebox.askyesno('Confirm', f'Remove player modifier index {idx}?'):
2005	            if self.editor.remove_modifier_by_index(self.slot, idx):
2006	                self._refresh()
2007	            else:
2008	                messagebox.showwarning('Failed', 'Unable to remove modifier')
2009	
2010	    def _remove_pokemon_mod(self):
2011	        sel = self.pokemon_tree.selection()
2012	        if not sel:
2013	            return
2014	        item = self.pokemon_tree.item(sel[0])
2015	        idx = item.get('values')[0]
2016	        try:
2017	            idx = int(idx)
2018	        except Exception:
2019	            return
2020	        if messagebox.askyesno('Confirm', f'Remove pokemon modifier index {idx}?'):
2021	            if self.editor.remove_modifier_by_index(self.slot, idx):
2022	                self._refresh()
2023	            else:
2024	                messagebox.showwarning('Failed', 'Unable to remove modifier')
2025	
2026	    def _upload(self):
2027	        if not messagebox.askyesno('Confirm Upload', 'Upload all modifier changes for this slot to the server?'):
2028	            return
2029	        try:
2030	            # Use current local file if present, else fetch live
2031	            from rogueeditor.utils import slot_save_path, load_json
2032	            p = slot_save_path(self.api.username, self.slot)
2033	            data = load_json(p) if os.path.exists(p) else self.api.get_slot(self.slot)
2034	            self.api.update_slot(self.slot, data)
2035	            messagebox.showinfo('Uploaded', 'Server updated successfully.')
2036	        except Exception as e:
2037	            messagebox.showerror('Upload failed', str(e))
2038	
2039	
2040	class CatalogSelectDialog(tk.Toplevel):
2041	    def __init__(self, master, name_to_id: dict[str, int], title: str = 'Select'):
2042	        super().__init__(master)
2043	        self.title(title)
2044	        self.geometry('400x400')
2045	        self.name_to_id = name_to_id
2046	        self._build()
2047	
2048	    def _build(self):
2049	        ttk.Label(self, text='Search:').pack(padx=6, pady=6, anchor=tk.W)
2050	        self.var = tk.StringVar()
2051	        ent = ttk.Entry(self, textvariable=self.var)
2052	        ent.pack(fill=tk.X, padx=6)
2053	        self.list = tk.Listbox(self)
2054	        self.list.pack(fill=tk.BOTH, expand=True, padx=6, pady=6)
2055	        self.list.bind('<Double-Button-1>', lambda e: self._ok())
2056	        self.list.bind('<Return>', lambda e: self._ok())
2057	        ttk.Button(self, text='Select', command=self._ok).pack(pady=6)
2058	        self.var.trace_add('write', self._on_change)
2059	        self._all = sorted(self.name_to_id.items(), key=lambda kv: kv[0])
2060	        self._filter('')
2061	        ent.focus_set()
2062	
2063	    def _on_change(self, *args):
2064	        self._filter(self.var.get().strip().lower().replace(' ', '_'))
2065	
2066	    def _filter(self, key: str):
2067	        self.list.delete(0, tk.END)
2068	        for name, iid in self._all:
2069	            if key in name:
2070	                self.list.insert(tk.END, f"{name} ({iid})")
2071	
2072	    def _ok(self):
2073	        try:
2074	            sel = self.list.get(self.list.curselection())
2075	        except Exception:
2076	            return
2077	        name = sel.split(' (', 1)[0]
2078	        self.result = self.name_to_id.get(name)
2079	        self.destroy()
2080	
2081	    @classmethod
2082	    def select(cls, master, name_to_id: dict[str, int], title: str = 'Select') -> int | None:
2083	        dlg = cls(master, name_to_id, title)
2084	        master.wait_window(dlg)
2085	        return getattr(dlg, 'result', None)

